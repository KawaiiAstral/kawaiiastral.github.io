^ 
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="author" content="Black-Astral" />
    <title>Astral Profile</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
      background: linear-gradient(135deg, #0f172a, #1e293b);
      background-size: 400% 400%;
      animation: bgFlow 15s ease infinite;
      color: #e2e8f0;
      font-family: 'M PLUS Rounded 1c', 'Meiryo', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    @keyframes bgFlow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translate(-50%, -20%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }
    header {
      text-align: center;
      margin-bottom: 2rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    header h1 {
      font-size: 2.4rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px #000;
      transition: text-shadow 0.3s ease;
    }
    header h1:hover {
      text-shadow: 2px 2px 4px #000;
    }
    header p {
      font-size: 1.15rem;
      color: #7dd3fc;
    }
    .profile-box {
      background: linear-gradient(to bottom, #2d3748, #1e293b);
      padding: 2rem;
      border-radius: 1.5rem;
      box-shadow: 0 12px 28px rgba(99,102,241,0.45);
      max-width: 30rem;
      width: 100%;
      margin-bottom: 2rem;
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .profile-box:hover {
      transform: translateY(-5px);
      box-shadow: 0 16px 32px rgba(99,102,241,0.55);
    }
    .profile-icon {
      width: 10rem;
      height: 10rem;
      border-radius: 50%;
      margin: 0 auto 1.2rem;
      border: 4px solid #7f9cf5;
      display: block;
      box-shadow: 0 0 14px rgba(124,58,237,0.6);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .profile-icon:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(124,58,237,0.8);
    }
    .profile-box h2,
    .profile-box p {
      text-align: center;
    }
    .profile-box h2 {
      font-size: 1.6rem;
      font-weight: 600;
    }
    .profile-box p {
      font-size: 1rem;
      color: #cbd5e0;
      margin-top: 0.5rem;
    }
    .link-section {
      background: #202938;
      border-radius: 1.25rem;
      padding: 2rem;
      box-shadow: 0 8px 20px rgba(99,102,241,0.35);
      max-width: 30rem;
      width: 100%;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .link-section:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 28px rgba(99,102,241,0.45);
    }
    .link-section h3 {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 1.2rem;
      text-align: center;
    }
    .link-section ul {
      list-style: none;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
    }
    .link-section a {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      color: #63b3ed;
      text-decoration: none;
      font-size: 1.05rem;
      padding: 0.7rem 1.2rem;
      border-radius: 0.8rem;
      background-color: rgba(99,102,241,0.12);
      transition: all 0.3s ease;
    }
    .link-section a:hover {
      background-color: rgba(99,102,241,0.25);
      color: #e0e7ff;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99,102,241,0.4);
    }
    /* XREAåºƒå‘Š */
    .xrea-banner {
      display: none;
      background: rgba(255,255,0,0.05);
      border: 2px solid rgba(255,255,0,0.7);
      border-radius: 1rem;
      box-shadow: 0 0 18px 3px rgba(255,255,0,0.4);
      padding: 1.5rem;
      margin-top: 2rem;
      width: 100%;
      max-width: 600px;
      text-align: center;
      color: #facc15;
      transition: opacity 0.3s ease;
    }
    .popup-info {
      overflow-y: auto;
      max-height: 80vh;
      padding-right: 15px;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .hidden-popup {
      overflow-y: auto;
      max-height: 70vh;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .omikuji-popup {
      overflow-y: auto;
      max-height: 60vh;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .popup-info.show,
    .hidden-popup.show,
    .omikuji-popup.show {
      display: block;
      opacity: 1;
      transform: translateX(-50%);
      animation: fadeInUp 0.3s ease;
    }
    .popup-info button {
      position: absolute;
      top: 0.5rem;
      right: 0.75rem;
      background: transparent;
      border: none;
      color: #f87171;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .omikuji-popup {
      top: 20%;
      max-width: 80%;
      width: 90%;
    }
    .show-btn {
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      padding: 0.75rem 1.6rem;
      font-size: 1rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 0.8rem;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    }
    .show-btn:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(37,99,235,0.4);
    }
    footer {
      margin-top: 2rem;
      color: #a0aec0;
      font-size: 0.85rem;
      text-align: center;
      transition: opacity 0.3s ease;
    }
    @media (max-width: 480px) {
      .profile-icon {
        width: 8rem;
        height: 8rem;
      }
      .profile-box h2 { font-size: 1.3rem; }
      .profile-box p { font-size: 0.95rem; }
      .link-section a {
        font-size: 0.95rem;
        padding: 0.6rem 1rem;
      }
      footer { font-size: 0.75rem; }
    }
    table.reversi-board {
      margin: 10px auto; border-collapse: collapse;
    }
    .reversi-board td {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      position: relative;
    }

    .reversi-board td.hint::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: rgba(0, 0, 0, 0.2); /* è–„ãé»’ã„ */
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    table.reversi-board td.black { background: radial-gradient(circle, #000 60%, transparent 60%); }
    table.reversi-board td.white { background: radial-gradient(circle, #fff 60%, transparent 60%); }

    /* Flip animation */
    @keyframes flip {
      0% {
        transform: rotateY(0deg);
      }
      50% {
        transform: rotateY(90deg);
        background: transparent;
      }
      100% {
        transform: rotateY(0deg);
      }
    }
    .flip {
      animation: flip 0.6s ease forwards;
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    #runnerCanvas {
      background-color: #87ceeb;
      border: 2px solid #000;
      display: block;
      margin: 0 auto;
    }
  </style>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-72E0Z6REMG"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-72E0Z6REMG');
  </script>
  </head>
  <script>
    const getCookie = (key) => {
      return document.cookie.split('; ').find(c => c.startsWith(key + '='))?.split('=')[1] || null;
    };

    const setCookie = (key, val, days) => {
      const d = new Date();
      d.setTime(d.getTime() + days * 864e5);
      document.cookie = `${key}=${val}; expires=${d.toUTCString()}; path=/`;
    };

    function showWarningA() {
      document.body.innerHTML = `
        <div style="padding:50px;font-family:'Courier New',monospace;color:#ff4d4d;background:#000;height:100vh;">
          <h1 style="font-size:3em;">âš ï¸ã€è­¦å‘Š - ä¸å¯©ãªæŒ™å‹•ã‚’æ¤œå‡ºã€‘âš ï¸</h1>
          <p style="font-size:1.4em;line-height:2;">
            ç¾åœ¨ã€ã“ã®ãƒšãƒ¼ã‚¸ã«ãŠã„ã¦<strong>é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®èµ·å‹•ã¾ãŸã¯ã‚³ãƒ¼ãƒ‰è§£æã®è©¦ã¿</strong>ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚<br><br>
            ã“ã®è¡Œç‚ºã¯ã€Webãƒšãƒ¼ã‚¸ã®ä¿è­·ã•ã‚ŒãŸæ§‹é€ ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç›®çš„ã¨ã—ãŸã‚‚ã®ã§ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€<br>
            <strong>ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢æ³•ï¼ˆæ—¥æœ¬ï¼‰ç¬¬3æ¡</strong>ç­‰ã®æ³•ä»¤ã«æŠµè§¦ã™ã‚‹æã‚ŒãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ãŠå®¢æ§˜ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ»ãƒ–ãƒ©ã‚¦ã‚¶æŒ‡ç´‹ãƒ»ã‚¢ã‚¯ã‚»ã‚¹çµŒè·¯ãƒ»æ“ä½œã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¯æ—¢ã«è¨˜éŒ²ã•ã‚Œã€<br>
            ç¶™ç¶šçš„ãªç›£è¦–å¯¾è±¡ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¾ã—ãŸã€‚<br><br>
            æœ¬ãƒšãƒ¼ã‚¸ã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿è­·ã®ãŸã‚ç•°å¸¸ã‚¢ã‚¯ã‚»ã‚¹ã«å¯¾ã—ã¦è‡ªå‹•å¿œç­”ã‚·ã‚¹ãƒ†ãƒ ã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚<br>
            ä¸æ­£ãªã‚¢ã‚¯ã‚»ã‚¹ãŒç¶™ç¶šã•ã‚Œã‚‹å ´åˆã€<strong>é€šä¿¡ã®é®æ–­ãƒ»åˆ¶é™ã€ã¾ãŸã¯æ³•çš„é€šçŸ¥</strong>ãŒè¡Œã‚ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ğŸ”’ã€è¨˜éŒ²æ¸ˆã¿æƒ…å ±ã€‘<br>
            â–¸ IPã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆåŒ¿ååŒ–ã•ã‚Œã¾ã›ã‚“ï¼‰<br>
            â–¸ User-Agent<br>
            â–¸ æ“ä½œå±¥æ­´ï¼ˆé–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®é–‹é–‰ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å«ã‚€ï¼‰<br><br>
            æœ¬ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚µãƒ¼ãƒãƒ¼ã¸é€ä¿¡ã•ã‚Œã€æ”¹ã–ã‚“ãƒ»å›é¿ã¯ã§ãã¾ã›ã‚“ã€‚<br><br>
            ğŸš«<strong>ã“ã‚Œä»¥ä¸Šã®è§£æè¡Œç‚ºã¯ç›´ã¡ã«ä¸­æ­¢ã—ã¦ãã ã•ã„ã€‚</strong>
          </p>
        </div>
      `;
    }


    function showWarningB() {
      document.body.innerHTML = `
        <div style="padding:50px;font-family:'Courier New',monospace;color:#ff0000;background:#000;height:100vh;">
          <h1 style="font-size:3em;">ğŸš¨ã€é‡å¤§è­¦å‘Šã€‘å†çŠ¯è¡Œç‚ºãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ ğŸš¨</h1>
          <p style="font-size:1.4em;line-height:2;">
            å†åº¦ã€é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ãƒ»ãƒšãƒ¼ã‚¸å†…éƒ¨æ§‹é€ ã®æ¤œæŸ»ã‚’è©¦ã¿ãŸç—•è·¡ãŒç¢ºèªã•ã‚Œã¾ã—ãŸã€‚<br><br>
            ã“ã‚Œã¯å˜ãªã‚‹é–²è¦§ã‚’è¶…ãˆãŸã€<strong>æ„å›³çš„ãªãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ»æ”¹ã–ã‚“è¡Œç‚º</strong>ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚<br><br>
            ğŸ“¡ ã™ã§ã«ä»¥ä¸‹ã®æƒ…å ±ãŒè¤‡æ•°å›è¨˜éŒ²ã•ã‚Œã€<strong>é«˜åº¦ãªç›£è¦–çŠ¶æ…‹</strong>ã«ç§»è¡Œã—ã¾ã—ãŸï¼š<br>
            â–¸ IPã‚¢ãƒ‰ãƒ¬ã‚¹<br>
            â–¸ ãƒ–ãƒ©ã‚¦ã‚¶è­˜åˆ¥æƒ…å ±ï¼ˆCanvas Fingerprint ç­‰ã‚’å«ã‚€ï¼‰<br>
            â–¸ æ“ä½œãƒ­ã‚°ï¼ˆè§£ææ—¥æ™‚ãƒ»æ»åœ¨æ™‚é–“ãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é †åºï¼‰<br><br>
            ã“ã®æƒ…å ±ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç®¡ç†è€…ã«å³æ™‚é€ä¿¡ã•ã‚Œã€<strong>èª¿æŸ»å¯¾è±¡ç«¯æœ«ã¨ã—ã¦ãƒªã‚¹ãƒˆåŒ–</strong>ã•ã‚Œã¾ã—ãŸã€‚<br><br>
            âš–ï¸ æœ¬è¡Œç‚ºãŒç¶šãå ´åˆã€æŠ€è¡“çš„æªç½®ã«åŠ ãˆã¦ã€<strong>ãƒ—ãƒ­ãƒã‚¤ãƒ€ã¸ã®é€šå‘Šãƒ»æ³•çš„æ‰‹ç¶šã</strong>ã‚’å–ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ğŸ” æœ¬ãƒšãƒ¼ã‚¸ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šä¿è­·ã•ã‚Œã¦ãŠã‚Šã€å›é¿ãƒ»å½è£…ã¯ä¸å¯èƒ½ã§ã™ã€‚<br>
            ã“ã®ã¾ã¾ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç¶™ç¶šã—ãŸå ´åˆã€<strong>å¼·åˆ¶é®æ–­ãƒ»æ°¸ç¶šçš„ãªã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢æªç½®</strong>ãŒå³åº§ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚<br><br>
            ğŸš¨<strong>ä»Šã™ãã™ã¹ã¦ã®é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã‚’é–‰ã˜ã€ãƒšãƒ¼ã‚¸ã‹ã‚‰é›¢ã‚Œã¦ãã ã•ã„ã€‚</strong>
          </p>
        </div>
      `;
    }


    function detectDebugger() {
      let triggered = false;

      let count = parseInt(getCookie("warn_count") || "0", 10);

      if (count >= 2) {
        showWarningB();
        return;
      }

      const check = () => {
        const before = new Date();
        debugger;
        const after = new Date();

        if (after - before > 10 && !triggered) {
          triggered = true;
          count++;
          setCookie("warn_count", count);
          if (count >= 2) {
            showWarningB();
          } else {
            setTimeout(showWarningA, 3000);
          }
        }
      };

      setInterval(check, 1000);
    }

    window.addEventListener("DOMContentLoaded", detectDebugger);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <body>
    <header>
      <h1>Welcome to Astral Site</h1>
      <p>Astral Profile</p>
    </header>
    <main>
      <section class="profile-box">
        <img src="https://i.gyazo.com/25618f47093149f3faff9c96caad3bb3.png" alt="Avatar" class="profile-icon" />
        <h2>Rusk&Sapphyä½¿ã„ / Black-Astral</h2>
        <p>è‡ªç”±ãã¾ã¾ã«ç”Ÿãã¦ã‚‹ç”Ÿç‰©ã€é›»è»ŠãŒã™ãã ã£ãŸã‚Š</p>
      </section>
      <section class="link-section">
        <h3>ğŸ”— ãƒªãƒ³ã‚¯é›†</h3>
        <ul>
          <li>
            <a href="https://vrchat.com/home/launch?worldId=wrld_545838b6-644e-4f2e-adec-65646637b788" target="_blank">ğŸŒ ãƒ›ãƒ¼ãƒ ãƒ¯ãƒ¼ãƒ«ãƒ‰</a>
          </li>
          <li>
            <a href="https://vrchat.com/home/user/usr_5e075627-8b85-4bce-9242-7f3fd2ade453" target="_blank">ğŸ’¬ VRChat ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«</a>
          </li>
          <li>
            <a href="https://x.com/AstralStelldayo" target="_blank">ğŸ¦ Xï¼ˆæ—§Twitterï¼‰</a>
          </li>
          <li>
            <a href="https://astralshop.booth.pm/" target="_blank">ğŸ› Booth</a>
          </li>
        </ul>
      </section>
      <section id="noticeBox" class="popup-info">
        <button onclick="hideNotice()">Ã—</button>
        <h3>ğŸ“¢ ãŠçŸ¥ã‚‰ã›</h3>
        <p>ç¾åœ¨ç‰¹ã« ãŠçŸ¥ã‚‰ã›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
      </section>
      <button class="show-btn" onclick="showNotice()">ãŠçŸ¥ã‚‰ã›ã‚’è¡¨ç¤º</button>
      <!-- XREAç”¨åºƒå‘Š -->
      <div class="xrea-banner" id="xreaAd">
        <h3>XREAç”¨åºƒå‘Š</h3>
        <script src="https://cache1.value-domain.com/xa.j?site=astraldao.s323.xrea.com"></script>
      </div>
    </main>
    <footer>
      <p>&copy; 2025 AstralSHOP. All Rights Reserved.</p>
      <p>Site Version 2025.4.16.0815</p>
    </footer>
    <script>
    const showNotice = () => {
      const notice = document.getElementById('noticeBox');
      if (notice) {
        notice.style.top = '20%';
        notice.classList.add('show');
      }
    };
    const hideNotice = () => {
      const notice = document.getElementById('noticeBox');
      if (notice) {
        notice.classList.remove('show');
      }
    };
    
    
    // DOMContentLoadedæ™‚ã®å‡¦ç†ï¼šXREAåºƒå‘Šè¡¨ç¤º
    window.addEventListener('DOMContentLoaded', () => {
      const ad = document.getElementById('xreaAd');
      if (ad && getCookie('adHidden') !== 'true') {
        ad.style.display = 'block';
        setTimeout(() => {
          ad.style.display = 'none';
          setCookie('adHidden', 'true', 7);
        }, 5000);
      }
    });
    
    let tapCount = 0, tapLimit = 10;
    const icon = document.querySelector('.profile-icon');
    if (icon) {
      icon.addEventListener('click', () => {
        tapCount++;
        if (tapCount === tapLimit) {
          showHiddenFeature();
          tapCount = 0;
        }
      });
    }
    
    const showHiddenFeature = () => {
      const existingPopup = document.querySelector('.hidden-popup');
      if(existingPopup) { existingPopup.remove(); }
      const hiddenFeature = document.createElement('div');
      hiddenFeature.className = 'hidden-popup';
      hiddenFeature.style.top = '20%';
      hiddenFeature.innerHTML = `
        <button onclick="this.parentElement.remove()" style="position:absolute;top:0.5rem;right:0.75rem;background:transparent;border:none;color:#f87171;font-size:1.2rem;cursor:pointer;">Ã—</button>
        <h3>ğŸ”’ éš ã—æ©Ÿèƒ½ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
        <p>å¥½ããªéŠã³ã‚’é¸ã‚“ã§ã­ï¼š</p>
        <div style="height: 1rem;"></div>
        <button onclick="startBlockGame()" class="show-btn">ğŸ® ãƒ–ãƒ­ãƒƒã‚¯ããšã—</button>
        <button onclick="startOmikuji()" class="show-btn" style="margin-top:0.5rem;">ğŸ² ãŠã¿ãã˜</button>
        <button onclick="initReactionGame()" class="show-btn" style="margin-top:0.5rem;">â± åå°„ç¥çµŒã‚²ãƒ¼ãƒ </button>
        <button onclick="initSnakeGame()" class="show-btn" style="margin-top:0.5rem;">ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ </button>
        <button onclick="initReversiGame()" class="show-btn" style="margin-top:0.5rem;">âšªï¸ãƒªãƒãƒ¼ã‚·</button>
        <button onclick="openWebOsu()" class="show-btn" style="margin-top:0.5rem;">ğŸµ osu</button>
        <button onclick="openMinesweeper()" class="show-btn" style="margin-top:0.5rem;">ğŸ’£ ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</button>
        <div id="hidden-content" style="margin-top:1rem;"></div>
      `;
      document.body.appendChild(hiddenFeature);
      setTimeout(() => { 
        hiddenFeature.classList.add('show'); 
        hiddenFeature.style.display = 'block';
      }, 10);
    };
    
    let blockLevel = 1;
    let blockBricks = [];

    function loadLevel(level) {
      blockBricks = [];
      const maxPresetLevels = 15;
      let rowCount = 3 + Math.floor(level / 2);
      let colCount = 5 + Math.floor(level / 3);
      if (level <= maxPresetLevels) {
        loadPresetLevel(level, rowCount, colCount);
      } else {
        for (let row = 0; row < rowCount; row++) {
          for (let col = 0; col < colCount; col++) {
            if (Math.random() > 0.3) {
              blockBricks.push({
                x: col * (50 + 5) + 20,
                y: row * (20 + 5) + 20,
                width: 50,
                height: 20,
                destroyed: false
              });
            }
          }
        }
      }
    }

    function loadPresetLevel(level, rows, cols) {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          blockBricks.push({
            x: col * (50 + 5) + 20,
            y: row * (20 + 5) + 20,
            width: 50,
            height: 20,
            destroyed: false
          });
        }
      }
    }

    function resetBallAndPaddle(canvas, ctx) {
      ballX = canvas.width / 2;
      ballY = canvas.height - 30;
      dx = 2;
      dy = -2;
      paddleX = (canvas.width - paddleWidth) / 2;
    }

    function nextBlockLevel(canvas, ctx) {
      blockLevel++;
      loadLevel(blockLevel);
      resetBallAndPaddle(canvas, ctx);
    }

    let ballX, ballY, dx, dy;
    let paddleX;
    const paddleHeight = 10, paddleWidth = 60;

    function startBlockGame() {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `<canvas id="blockGame" width="300" height="200" style="background:#111; display:block; margin:1rem auto; border:2px solid #ccc;"></canvas>`;
  
      const canvas = document.getElementById("blockGame");
      const ctx = canvas.getContext("2d");

      let rightPressed = false, leftPressed = false, upPressed = false, downPressed = false;

      document.addEventListener("keydown", (e) => {
        if (e.key === "d" || e.key === "D") rightPressed = true;
        else if (e.key === "a" || e.key === "A") leftPressed = true;
        else if (e.key === "w" || e.key === "W") upPressed = true; 
        else if (e.key === "s" || e.key === "S") downPressed = true; 
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "d" || e.key === "D") rightPressed = false;
        else if (e.key === "a" || e.key === "A") leftPressed = false;
        else if (e.key === "w" || e.key === "W") upPressed = false;
        else if (e.key === "s" || e.key === "S") downPressed = false;
      });

      blockLevel = 1;
      loadLevel(blockLevel);
      resetBallAndPaddle(canvas, ctx);

      function collisionDetection() {
        blockBricks.forEach((brick) => {
          if (!brick.destroyed) {
            if (
              ballX > brick.x &&
              ballX < brick.x + brick.width &&
              ballY > brick.y &&
              ballY < brick.y + brick.height
            ) {
              dy = -dy;
              brick.destroyed = true;
            }
          }
        });
      }

      function drawBlockGame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
        blockBricks.forEach((brick) => {
          if (!brick.destroyed) {
            ctx.beginPath();
            ctx.rect(brick.x, brick.y, brick.width, brick.height);
            ctx.fillStyle = "#34d399";
            ctx.fill();
            ctx.closePath();
          }
        });

        ctx.beginPath();
        ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
        ctx.fillStyle = "#63b3ed";
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = "#facc15";
        ctx.fill();
        ctx.closePath();

        collisionDetection();

        if (ballX + dx > canvas.width - 5 || ballX + dx < 5) {
          dx = -dx;
        }
        if (ballY + dy < 5) {
          dy = -dy;
        } else if (ballY + dy > canvas.height - 5) {
          if (ballX > paddleX && ballX < paddleX + paddleWidth) {
            dy = -dy;
          } else {
            hiddenContent.innerHTML = "<p style='color:tomato;text-align:center;margin-top:1rem;'>ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ã‚‚ã†ä¸€åº¦ãƒ–ãƒ­ãƒƒã‚¯ããšã—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†é–‹</p>";
            return;
          }
        }

        ballX += dx;
        ballY += dy;
        if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
        else if (leftPressed && paddleX > 0) paddleX -= 5;

        if (blockBricks.every(brick => brick.destroyed)) {
          nextBlockLevel(canvas, ctx);
        }

        requestAnimationFrame(drawBlockGame);
      }

      drawBlockGame();
    }

    
    const startOmikuji = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div class="omikuji-loading" style="padding:1rem; text-align:center; border:2px solid #63b3ed; border-radius:0.8rem; background:#1e293b; margin-top:1rem;">
          <h3>ãŠã¿ãã˜ã‚’å¼•ã„ã¦ã„ã¾ã™â€¦</h3>
          <div class="spinner" style="margin:1rem auto; width:40px; height:40px; border:4px solid #63b3ed; border-top:4px solid #1e293b; border-radius:50%; animation: spin 1s linear infinite;"></div>
        </div>
      `;
      setTimeout(() => {
        const results = [ "å¤§å‰ ğŸ‰", "ä¸­å‰ ğŸ™‚", "å°å‰ ğŸ˜Š", "å‰ ğŸ‘", "æœ«å‰ ğŸ¤", "å‡¶ ğŸ˜", "å¤§å‡¶ ğŸ’¥" ];
        const randomResult = results[Math.floor(Math.random() * results.length)];
        hiddenContent.innerHTML = `
          <div style="padding:1rem; text-align:center; border:2px solid #63b3ed; border-radius:0.8rem; background:#1e293b; margin-top:1rem; transition: transform 0.3s ease;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
            <h3>ãŠã¿ãã˜ã®çµæœ</h3>
            <p style="font-size:1.5rem; font-weight:bold;">${randomResult}</p>
          </div>
        `;
      }, 2000);
    };
    
    let reactionStartTime, reactionTimeoutId;
    let reactionIsWaiting = false, reactionHasStarted = false;
    const initReactionGame = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div id="reactionGame" style="text-align:center; padding:20px;">
          <h2>ğŸ§  åå°„ç¥çµŒã‚²ãƒ¼ãƒ </h2>
          <div id="reactionBox" style="width:300px; height:200px; margin:20px auto; background-color:gray; line-height:200px; font-size:24px; color:white; cursor:pointer; border-radius:12px;">
            ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
          </div>
          <p id="reactionResult" style="font-size:1.5em; margin-top:20px; font-weight:bold;"></p>
          <button onclick="startReactionGame()" style="margin-top:20px; padding:10px 20px; font-size:1em; border:none; border-radius:8px; background-color:#2196f3; color:white; cursor:pointer;">
            ãƒªãƒˆãƒ©ã‚¤
          </button>
        </div>
      `;
      reactionStartTime = null;
      reactionTimeoutId = null;
      reactionIsWaiting = false;
      reactionHasStarted = false;
      setupReactionGame();
    };
    const setupReactionGame = () => {
      const reactionBox = document.getElementById("reactionBox");
      const reactionResult = document.getElementById("reactionResult");
      reactionBox.addEventListener("click", () => {
        if (!reactionHasStarted) {
          startReactionGame();
          return;
        }
        if (reactionIsWaiting) {
          clearTimeout(reactionTimeoutId);
          reactionResult.textContent = "âš ï¸ æ—©ã™ãï¼ã‚„ã‚Šç›´ã—ã¦ã­ã€‚";
          reactionBox.style.backgroundColor = "#f44336";
          reactionBox.textContent = "æ—©ã™ãï¼";
          reactionHasStarted = false;
        } else if (reactionStartTime) {
          const reactionTime = Date.now() - reactionStartTime;
          let comment = "";
          if (reactionTime < 200) comment = "ğŸ‘‘ ç¥åå¿œï¼";
          else if (reactionTime < 300) comment = "âš¡ é€Ÿã„ï¼";
          else if (reactionTime < 500) comment = "ğŸ‘ æ™®é€š";
          else comment = "ğŸ¢ é…ã‚...";
          reactionResult.textContent = `åå¿œé€Ÿåº¦: ${reactionTime} ms ${comment}`;
          reactionBox.textContent = "ã‚‚ã†ä¸€å›ï¼Ÿ";
          reactionBox.style.backgroundColor = "#2196f3";
          reactionHasStarted = false;
        }
      });
    };
    const startReactionGame = () => {
      const reactionBox = document.getElementById("reactionBox");
      const reactionResult = document.getElementById("reactionResult");
      reactionBox.style.backgroundColor = "gray";
      reactionBox.textContent = "å¾…ã£ã¦...";
      reactionResult.textContent = "";
      reactionIsWaiting = true;
      reactionHasStarted = true;
      reactionTimeoutId = setTimeout(() => {
        reactionBox.style.backgroundColor = "#4caf50";
        reactionBox.textContent = "ã‚¯ãƒªãƒƒã‚¯ï¼";
        reactionStartTime = Date.now();
        reactionIsWaiting = false;
      }, 2000 + Math.random() * 3000);
    };
    
    const initSnakeGame = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div id="snakeGameContainer" style="text-align:center;">
          <h2>ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ </h2>
          <canvas id="snakeCanvas" width="400" height="400" style="background-color:#000; border:2px solid #0f0; margin:0 auto;"></canvas>
          <p>çŸ¢å°ã‚­ãƒ¼ã§æ“ä½œã—ã¦ã­ï¼</p>
        </div>
      `;
      const canvas = document.getElementById("snakeCanvas");
      const ctx = canvas.getContext("2d");
      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      let snake = [{ x: 10, y: 10 }];
      let apple = { x: 5, y: 5 };
      let dx = 1, dy = 0;
      let gameOver = false;
      function drawSnakeGame() {
        if (gameOver) return;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f00";
        ctx.fillRect(apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);
        ctx.fillStyle = "#0f0";
        snake.forEach(part => { ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize); });
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount ||
            snake.some(part => part.x === head.x && part.y === head.y)) {
          gameOver = true;
          alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼");
          location.reload();
          return;
        }
        snake.unshift(head);
        if (head.x === apple.x && head.y === apple.y) {
          apple = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
        } else {
          snake.pop();
        }
        setTimeout(drawSnakeGame, 100);
      }
      document.addEventListener("keydown", snakeKeyDown);
      function snakeKeyDown(e) {
        if (e.key === "ArrowUp" && dy === 0) { dx = 0; dy = -1; }
        else if (e.key === "ArrowDown" && dy === 0) { dx = 0; dy = 1; }
        else if (e.key === "ArrowLeft" && dx === 0) { dx = -1; dy = 0; }
        else if (e.key === "ArrowRight" && dx === 0) { dx = 1; dy = 0; }
      }
      drawSnakeGame();
    };
    
    const initReversiGame = () => {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div id="reversiGame" style="text-align:center;">
      <h2>ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰</h2>
      <table class="reversi-board" id="reversiBoard"></table>
      <p id="reversiStatus"></p>
      <canvas id="scoreChart" width="400" height="200"></canvas>  
      <p id="gameResult"></p> 
    </div>
  `;

  const size = 8, BOT = 2;
  let board = [], currentPlayer = 1, lastMove = null;
  const statusElem = document.getElementById("reversiStatus");
  const gameResultElem = document.getElementById("gameResult");

  const ctx = document.getElementById('scoreChart').getContext('2d');
  const scoreData = {
    labels: [],
    datasets: [{
      label: 'ã‚¹ã‚³ã‚¢',
      borderColor: 'rgba(75, 192, 192, 1)',
      data: [],
      fill: false,
      tension: 0.1
    },
    {
      label: 'äºˆæ¸¬ã‚¹ã‚³ã‚¢',
      borderColor: 'rgba(255, 99, 132, 1)',
      data: [],
      fill: false,
      tension: 0.1,
      borderDash: [5, 5] 
    }]
  };
  const scoreChart = new Chart(ctx, {
    type: 'line',
    data: scoreData,
    options: {
      scales: {
        x: {
          title: {
            display: true,
            text: 'ã‚¿ãƒ¼ãƒ³'
          }
        },
        y: {
          title: {
            display: true,
            text: 'è©•ä¾¡ã‚¹ã‚³ã‚¢'
          },
          suggestedMin: -1000,
          suggestedMax: 1000
        }
      }
    }
  });

  const weights = [
    [120, -20, 20, 5, 5, 20, -20, 120],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [120, -20, 20, 5, 5, 20, -20, 120]
  ];

  const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
  const transpositionTable = new Map();
  const zobristTable = Array.from({ length: size }, () =>
    Array.from({ length: size }, () => [Math.random() * 2**32, Math.random() * 2**32])
  );

  let zobristHash = 0;
  const initZobrist = () => zobristHash = computeHash();
  const computeHash = () => {
    let hash = 0;
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const val = board[r][c];
        if (val) hash ^= zobristTable[r][c][val - 1];
      }
    }
    return hash;
  };

  const initBoard = () => {
    board = Array.from({ length: size }, () => Array(size).fill(0));
    board[3][3] = board[4][4] = BOT;
    board[3][4] = board[4][3] = 1;
    initZobrist();
  };

  const renderBoard = () => {
    const table = document.getElementById("reversiBoard");
    table.innerHTML = "";
    for (let r = 0; r < size; r++) {
      const tr = document.createElement("tr");
      for (let c = 0; c < size; c++) {
        const td = document.createElement("td");
        td.dataset.row = r;
        td.dataset.col = c;
        td.className = board[r][c] === 1 ? "black" : board[r][c] === BOT ? "white" : "";
        td.style.outline = lastMove?.row === r && lastMove.col === c ? "2px solid red" : "";
        if (currentPlayer === 1 && board[r][c] === 0 && isLegal(r, c)) td.classList.add("hint");
        if (currentPlayer === 1) td.addEventListener("click", cellClick);
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚’æ›´æ–°
    statusElem.textContent = currentPlayer === 1 ? "ã‚ãªãŸ(é»’)ã®ã‚¿ãƒ¼ãƒ³" : "BOT(ç™½)ã®ã‚¿ãƒ¼ãƒ³";
  };

  const isLegal = (r, c) =>
    board[r][c] === 0 && directions.some(([dr, dc]) => checkDirection(r, c, dr, dc));

  const checkDirection = (r, c, dr, dc) => {
    let i = r + dr, j = c + dc, found = false;
    while (i >= 0 && i < size && j >= 0 && j < size) {
      if (board[i][j] === 0) return false;
      if (board[i][j] === currentPlayer) return found;
      found = true;
      i += dr; j += dc;
    }
    return false;
  };

  const flipDirection = (r, c, dr, dc) => {
    let i = r + dr, j = c + dc;
    while (board[i][j] !== currentPlayer) {
      const cell = document.querySelector(`#reversiBoard tr:nth-child(${i + 1}) td:nth-child(${j + 1})`);
      if (cell) {
        cell.classList.add('flip');
        cell.addEventListener('animationend', () => {
          cell.classList.remove('flip');
          // Update the cell color class after flip animation
          if (currentPlayer === 1) {
            cell.classList.remove('white');
            cell.classList.add('black');
          } else {
            cell.classList.remove('black');
            cell.classList.add('white');
          }
        }, { once: true });
      }
      zobristHash ^= zobristTable[i][j][board[i][j]-1];
      board[i][j] = currentPlayer;
      zobristHash ^= zobristTable[i][j][currentPlayer-1];
      i += dr; j += dc;
    }
  };

  const legalMoves = (player) => {
    const originalPlayer = currentPlayer;
    currentPlayer = player;
    const moves = [];
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (isLegal(r, c)) moves.push([r, c]);
      }
    }
    currentPlayer = originalPlayer;
    return moves;
  };

  const evaluateBoard = () => {
    let score = 0, mobility = 0;
    let stable = 0;

    const stableTable = Array.from({ length: size }, () => Array(size).fill(false));
    const isStable = (r, c, color) => {
      if (board[r][c] !== color || stableTable[r][c]) return false;
      for (let [dr, dc] of directions) {
        let nr = r + dr, nc = c + dc;
        if (nr < 0 || nr >= size || nc < 0 || nc >= size) continue;
        if (board[nr][nc] !== color) return false;
      }
      return true;
    };

    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const val = board[r][c];
        if (!val) continue;
        score += weights[r][c] * (val === BOT ? 1 : -1);
        if (isStable(r, c, val)) {
          stable += val === BOT ? 5 : -5;
          stableTable[r][c] = true;
        }
      }
    }

    mobility += legalMoves(BOT).length - legalMoves(1).length;

    const empty = board.flat().filter(v => v === 0).length;
    if (empty < 12) {
      const count = board.flat().reduce((a, b) => {
        if (b === BOT) a.bot++;
        else if (b === 1) a.human++;
        return a;
      }, { bot: 0, human: 0 });
      return (count.bot - count.human) * 1000;
    }

    return score + mobility * 5 + stable;
  };

  const applyMove = (r, c, player, record = false) => {
    currentPlayer = player;
    zobristHash ^= zobristTable[r][c][player - 1];
    board[r][c] = player;
    directions.forEach(([dr, dc]) => {
      if (checkDirection(r, c, dr, dc)) flipDirection(r, c, dr, dc);
    });
    if (record) lastMove = { row: r, col: c };
  };

  const getSortedMoves = (moves, player) =>
    moves.map(m => ({ move: m, score: weights[m[0]][m[1]] }))
         .sort((a, b) => player === BOT ? b.score - a.score : a.score - b.score)
         .map(ms => ms.move);

  const minimax = (depth, alpha, beta, isMax) => {
    const key = zobristHash + "-" + depth + (isMax ? "M" : "m");
    if (transpositionTable.has(key)) return transpositionTable.get(key);

    const player = isMax ? BOT : 1;
    const moves = getSortedMoves(legalMoves(player), player);
    if (depth === 0 || moves.length === 0) return { score: evaluateBoard() };

    let best = null;
    if (isMax) {
      let maxEval = -Infinity;
      for (const [r, c] of moves) {
        const snap = board.map(row => row.slice()), hashBackup = zobristHash;
        applyMove(r, c, BOT);
        const eval = minimax(depth - 1, alpha, beta, false).score;
        board = snap; zobristHash = hashBackup;
        if (eval > maxEval) {
          maxEval = eval;
          best = [r, c];
        }
        alpha = Math.max(alpha, eval);
        if (beta <= alpha) break;
      }
      const res = { score: maxEval, move: best };
      transpositionTable.set(key, res);
      return res;
    } else {
      let minEval = Infinity;
      for (const [r, c] of moves) {
        const snap = board.map(row => row.slice()), hashBackup = zobristHash;
        applyMove(r, c, 1);
        const eval = minimax(depth - 1, alpha, beta, true).score;
        board = snap; zobristHash = hashBackup;
        if (eval < minEval) {
          minEval = eval;
          best = [r, c];
        }
        beta = Math.min(beta, eval);
        if (beta <= alpha) break;
      }
      const res = { score: minEval, move: best };
      transpositionTable.set(key, res);
      return res;
    }
  };

  const iterativeDeepening = (maxDepth, timeLimit = 1000) => {
    let best = null, start = Date.now();
    for (let d = 1; d <= maxDepth; d++) {
      const result = minimax(d, -Infinity, Infinity, true);
      if (result.move) best = result;
      if (Date.now() - start > timeLimit) break;
    }
    return best;
  };

  const checkGameEnd = () => {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®åˆæ³•æ‰‹ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const playerMoves = legalMoves(1);
    // BOTã®åˆæ³•æ‰‹ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const botMoves = legalMoves(BOT);
    
    // ä¸¡æ–¹ã¨ã‚‚æ‰‹ãŒãªã„å ´åˆã€ã¾ãŸã¯ç›¤é¢ãŒåŸ‹ã¾ã£ã¦ã„ã‚‹å ´åˆ
    const empty = board.flat().filter(v => v === 0).length;
    if ((playerMoves.length === 0 && botMoves.length === 0) || empty === 0) {
      const botScore = board.flat().filter(v => v === BOT).length;
      const humanScore = board.flat().filter(v => v === 1).length;
      if (botScore > humanScore) {
        gameResultElem.textContent = `BOTã®å‹ã¡ï¼ (BOT: ${botScore}, ã‚ãªãŸ: ${humanScore})`;
      } else if (botScore < humanScore) {
        gameResultElem.textContent = `ã‚ãªãŸã®å‹ã¡ï¼ (ã‚ãªãŸ: ${humanScore}, BOT: ${botScore})`;
      } else {
        gameResultElem.textContent = `å¼•ãåˆ†ã‘ï¼ (${humanScore}å¯¾${botScore})`;
      }
      return true;
    }
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ãŒæ‰‹ãŒãªãã€BOTãŒæ‰‹ãŒã‚ã‚‹å ´åˆ
    if (playerMoves.length === 0 && botMoves.length > 0) {
      statusElem.textContent = "ã‚ãªãŸã¯ãƒ‘ã‚¹ã§ã™ã€‚BOT(ç™½)ã®ã‚¿ãƒ¼ãƒ³";
      setTimeout(() => {
        currentPlayer = BOT;
        makeMove();
      }, 1000);
      return true;
    }
    
    // BOTãŒæ‰‹ãŒãªãã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ãŒæ‰‹ãŒã‚ã‚‹å ´åˆ
    if (botMoves.length === 0 && playerMoves.length > 0) {
      statusElem.textContent = "BOTã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸ(é»’)ã®ã‚¿ãƒ¼ãƒ³";
      currentPlayer = 1;
      renderBoard();
      return true;
    }
    
    return false;
  };

  const makeMove = () => {
    const botMoves = legalMoves(BOT);
    if (botMoves.length > 0) {
      const { move } = iterativeDeepening(4);
      if (move) {
        applyMove(move[0], move[1], BOT, true);
        lastMove = { row: move[0], col: move[1] };
        scoreData.labels.push(`ã‚¿ãƒ¼ãƒ³ ${scoreData.labels.length + 1}`);
        scoreData.datasets[0].data.push(evaluateBoard());

        const predictedScore = evaluateBoard(); 
        scoreData.datasets[1].data.push(predictedScore);

        scoreChart.update();
      }
    }
    
    // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
    if (!checkGameEnd()) {
      currentPlayer = 1;
      renderBoard();
    }
  };

  const cellClick = (event) => {
    const row = +event.target.dataset.row, col = +event.target.dataset.col;
    if (board[row][col] !== 0 || !isLegal(row, col)) return;
    
    applyMove(row, col, 1, true);
    scoreData.labels.push(`ã‚¿ãƒ¼ãƒ³ ${scoreData.labels.length + 1}`);
    scoreData.datasets[0].data.push(evaluateBoard());

    const predictedScore = evaluateBoard(); 
    scoreData.datasets[1].data.push(predictedScore);

    scoreChart.update();
    renderBoard();
    
    // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
    if (!checkGameEnd()) {
      currentPlayer = BOT;
      renderBoard(); // BOTã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã«æ›´æ–°
      setTimeout(makeMove, 1000);
    }
  };

  initBoard();
  renderBoard();
};

initReversiGame();







  const initRunnerGame = () => {
    const hiddenContent = document.getElementById('hidden-content');
    hiddenContent.innerHTML = `
      <div id="runnerGameContainer" style="text-align:center;">
        <h2>ğŸƒ ãƒ©ãƒ³ãƒŠãƒ¼ã‚²ãƒ¼ãƒ </h2>
        <canvas id="runnerCanvas" width="400" height="200" style="background-color:#87ceeb; border:2px solid #000; display:block; margin:0 auto;"></canvas>
        <p id="runnerScore">Score: 0</p>
        <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã‚’ã‚¿ãƒƒãƒ—ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼</p>
      </div>
    `;
    const canvas = document.getElementById("runnerCanvas");
    const ctx = canvas.getContext("2d");
    let runner = { x: 50, y: 150, width: 30, height: 30, vy: 0, jumping: false };
    const groundY = 150;
    const gravity = 0.6;
    let obstacles = [];
    let score = 0;
    let gameOver = false;
    let obstacleInterval = 1500; 
    let lastObstacleTime = Date.now();
    
    function drawRunnerGame() {
      if (gameOver) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#654321";
      ctx.fillRect(0, groundY + runner.height, canvas.width, canvas.height - groundY - runner.height);
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(runner.x, runner.y, runner.width, runner.height);
      runner.vy += gravity;
      runner.y += runner.vy;
      if (runner.y > groundY) {
        runner.y = groundY;
        runner.vy = 0;
        runner.jumping = false;
      }
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.x -= 5;
        ctx.fillStyle = "#000";
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        if (runner.x < obs.x + obs.width &&
            runner.x + runner.width > obs.x &&
            runner.y < obs.y + obs.height &&
            runner.y + runner.height > obs.y) {
          gameOver = true;
          alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ ã‚¹ã‚³ã‚¢: " + score);
          location.reload();
          return;
        }
        if (obs.x + obs.width < 0) {
          obstacles.splice(i, 1);
          score += 10;
          document.getElementById("runnerScore").textContent = "Score: " + score;
        }
      }
      if (Date.now() - lastObstacleTime > obstacleInterval) {
        const obsHeight = Math.random() * 20 + 20;
        obstacles.push({
          x: canvas.width,
          y: groundY + runner.height - obsHeight,
          width: 20,
          height: obsHeight
        });
        lastObstacleTime = Date.now();
      }
      requestAnimationFrame(drawRunnerGame);
    }
    drawRunnerGame();
    
    window.addEventListener("keydown", runnerKeyDown);
    function runnerKeyDown(e) {
      if (e.code === "Space" && !e.repeat) {  
        if (!runner.jumping) {
          runner.vy = -12;
          runner.jumping = true;
        }
      }
    }
  };
  function openWebOsu() {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div style="position: relative; width: 100%; height: 600px; border: 2px solid #ccc; border-radius: 0.8rem; overflow: auto;">
      <button onclick="closeWebOsu()" style="position: absolute; top: 0.5rem; right: 0.5rem; z-index:2; background:transparent;border:none;color:#f87171;font-size:1.2rem;cursor:pointer;">Ã—</button>
      <div style="width: 1280px; height: 800px; transform: scale(1); transform-origin: top left;">
        <iframe src="https://webosu.online/" style="width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
      </div>
      <div style="position: absolute; bottom: 0.3rem; right: 0.5rem; font-size: 0.75rem; color: #aaa; font-style: italic;">
        Powered by BlaNKtext
      </div>
    </div>
  `;
}


  function closeWebOsu() {
    const hiddenContent = document.getElementById('hidden-content');
    hiddenContent.innerHTML = "";
  }

function openMinesweeper() {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div style="position: relative; width: 100%; max-height: 90vh; overflow-y: auto; border: 1px solid #ccc; border-radius: 0.75rem; padding: 1rem; background: #f9fafb; box-shadow: 0 0 10px rgba(0,0,0,0.05);">
      <button onclick="closeMinesweeper()" style="position: absolute; top: 0.5rem; right: 0.5rem; z-index: 2; background: transparent; border: none; color: #ef4444; font-size: 1.2rem; cursor: pointer;">Ã—</button>
      <h2 style="margin-top: 0; font-size: 1.25rem; color: #374151;">ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</h2>
      <div id="controls" style="margin-bottom: 10px; display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
        <button onclick="init(9, 9, 10)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">åˆç´š</button>
        <button onclick="init(16, 16, 40)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">ä¸­ç´š</button>
        <button onclick="init(30, 16, 99)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">ä¸Šç´š</button>
      </div>
      <div id="status" style="font-weight: bold; margin: 0.5rem 0; color: #1f2937;">ğŸš© æ®‹ã‚Š: <span id="mine-count">0</span></div>
      <div id="game" style="display: grid; justify-content: center; gap: 2px;"></div>
    </div>
  `;

  const style = document.createElement('style');
  style.textContent = `
    .cell {
      width: 30px;
      height: 30px;
      background-color: #d1d5db;
      text-align: center;
      line-height: 30px;
      font-family: monospace;
      cursor: pointer;
      user-select: none;
      border-radius: 0.25rem;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    .cell:active {
      transform: scale(0.95);
    }
    .cell.opened {
      background-color: #f3f4f6 !important;
      cursor: default;
    }
    .cell.mine {
      background-color: #f87171 !important;
    }
    .cell.flagged {
      background-color: #c7d2fe !important;
    }
    .difficulty-btn.active {
      background-color: #3b82f6 !important;
      color: white;
    }
  `;
  document.head.appendChild(style);

  const script = document.createElement('script');
  script.type = 'text/javascript';
  script.text = `
    let board = [], width, height, mines, firstClick, openedCount, flaggedCount;

    function init(w, h, m) {
      width = w;
      height = h;
      mines = m;
      board = [];
      firstClick = true;
      openedCount = 0;
      flaggedCount = 0;
      const game = document.getElementById('game');
      game.innerHTML = '';
      game.style.gridTemplateColumns = \`repeat(\${width}, 30px)\`;
      game.style.gridTemplateRows = \`repeat(\${height}, 30px)\`;
      document.getElementById('status').style.color = '#1f2937';
      updateMineCount();

      document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
      const idx = [10, 40, 99].indexOf(m);
      if (idx !== -1) document.querySelectorAll('.difficulty-btn')[idx].classList.add('active');

      for (let y = 0; y < height; y++) {
        board[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.oncontextmenu = (e) => {
            e.preventDefault();
            toggleFlag(x, y);
          };
          cell.onclick = () => handleClick(x, y);
          game.appendChild(cell);

          board[y][x] = {
            el: cell,
            mine: false,
            opened: false,
            flagged: false,
            adjacent: 0
          };
        }
      }
    }

    function handleClick(x, y) {
      const cell = board[y][x];
      if (cell.opened || cell.flagged) return;

      if (firstClick) {
        placeMines(x, y);
        calcAdjacent();
        firstClick = false;
      }

      openCell(x, y);
      checkWin();
    }

    function toggleFlag(x, y) {
      const cell = board[y][x];
      if (cell.opened) return;
      cell.flagged = !cell.flagged;
      if (cell.flagged) {
        flaggedCount++;
        cell.el.textContent = 'ğŸš©';
        cell.el.classList.add('flagged');
      } else {
        flaggedCount--;
        cell.el.textContent = '';
        cell.el.classList.remove('flagged');
      }
      updateMineCount();
    }

    function updateMineCount() {
      const left = Math.max(mines - flaggedCount, 0);
      document.getElementById('mine-count').textContent = left;
    }

    function placeMines(safeX, safeY) {
      let placed = 0;
      while (placed < mines) {
        const x = Math.floor(Math.random() * width);
        const y = Math.floor(Math.random() * height);
        if (Math.abs(x - safeX) <= 1 && Math.abs(y - safeY) <= 1) continue;
        if (!board[y][x].mine) {
          board[y][x].mine = true;
          placed++;
        }
      }
    }

    function calcAdjacent() {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (board[y][x].mine) continue;
          let count = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                if (board[ny][nx].mine) count++;
              }
            }
          }
          board[y][x].adjacent = count;
        }
      }
    }

    function openCell(x, y) {
      const cell = board[y][x];
      if (cell.opened || cell.flagged) return;
      cell.opened = true;
      cell.el.classList.add('opened');
      openedCount++;

      if (cell.mine) {
        cell.el.textContent = 'ğŸ’£';
        cell.el.classList.add('mine');
        showStatus('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼', true);
        revealAll();
        return;
      }

      if (cell.adjacent > 0) {
        cell.el.textContent = cell.adjacent;
      } else {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
              openCell(nx, ny);
            }
          }
        }
      }
    }

    function revealAll() {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.opened) {
            cell.el.textContent = 'ğŸ’£';
            cell.el.classList.add('mine');
          }
          cell.el.onclick = null;
          cell.el.oncontextmenu = null;
        }
      }
    }

    function checkWin() {
      if (openedCount === width * height - mines) {
        showStatus('ğŸ‰ ã‚¯ãƒªã‚¢ï¼', false);
        revealAll();
      }
    }

    function showStatus(msg, isFail) {
      const status = document.getElementById('status');
      status.textContent = msg;
      status.style.color = isFail ? '#dc2626' : '#10b981';
    }

    init(9, 9, 10);
  `;
  document.body.appendChild(script);
}
function closeMinesweeper() {
  document.getElementById('hidden-content').innerHTML = '';
}
  </script>
  </body>
</html>