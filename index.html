^ 
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="author" content="Black-Astral" />
    <title>Astral Profile</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
      background: linear-gradient(135deg, #0f172a, #1e293b);
      background-size: 400% 400%;
      animation: bgFlow 15s ease infinite;
      color: #e2e8f0;
      font-family: 'M PLUS Rounded 1c', 'Meiryo', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    @keyframes bgFlow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translate(-50%, -20%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }
    header {
      text-align: center;
      margin-bottom: 2rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    header h1 {
      font-size: 2.4rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
      text-shadow: 1px 1px 2px #000;
      transition: text-shadow 0.3s ease;
    }
    header h1:hover {
      text-shadow: 2px 2px 4px #000;
    }
    header p {
      font-size: 1.15rem;
      color: #7dd3fc;
    }
    .profile-box {
      background: linear-gradient(to bottom, #2d3748, #1e293b);
      padding: 2rem;
      border-radius: 1.5rem;
      box-shadow: 0 12px 28px rgba(99,102,241,0.45);
      max-width: 30rem;
      width: 100%;
      margin-bottom: 2rem;
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .profile-box:hover {
      transform: translateY(-5px);
      box-shadow: 0 16px 32px rgba(99,102,241,0.55);
    }
    .profile-icon {
      width: 10rem;
      height: 10rem;
      border-radius: 50%;
      margin: 0 auto 1.2rem;
      border: 4px solid #7f9cf5;
      display: block;
      box-shadow: 0 0 14px rgba(124,58,237,0.6);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .profile-icon:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(124,58,237,0.8);
    }
    .profile-box h2,
    .profile-box p {
      text-align: center;
    }
    .profile-box h2 {
      font-size: 1.6rem;
      font-weight: 600;
    }
    .profile-box p {
      font-size: 1rem;
      color: #cbd5e0;
      margin-top: 0.5rem;
    }
    .link-section {
      background: #202938;
      border-radius: 1.25rem;
      padding: 2rem;
      box-shadow: 0 8px 20px rgba(99,102,241,0.35);
      max-width: 30rem;
      width: 100%;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .link-section:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 28px rgba(99,102,241,0.45);
    }
    .link-section h3 {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 1.2rem;
      text-align: center;
    }
    .link-section ul {
      list-style: none;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
    }
    .link-section a {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      color: #63b3ed;
      text-decoration: none;
      font-size: 1.05rem;
      padding: 0.7rem 1.2rem;
      border-radius: 0.8rem;
      background-color: rgba(99,102,241,0.12);
      transition: all 0.3s ease;
    }
    .link-section a:hover {
      background-color: rgba(99,102,241,0.25);
      color: #e0e7ff;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99,102,241,0.4);
    }
    /* XREAåºƒå‘Š */
    .xrea-banner {
      display: none;
      background: rgba(255,255,0,0.05);
      border: 2px solid rgba(255,255,0,0.7);
      border-radius: 1rem;
      box-shadow: 0 0 18px 3px rgba(255,255,0,0.4);
      padding: 1.5rem;
      margin-top: 2rem;
      width: 100%;
      max-width: 600px;
      text-align: center;
      color: #facc15;
      transition: opacity 0.3s ease;
    }
    .popup-info {
      overflow-y: auto;
      max-height: 80vh;
      padding-right: 15px;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .hidden-popup {
      overflow-y: auto;
      max-height: 70vh;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .omikuji-popup {
      overflow-y: auto;
      max-height: 60vh;
      position: fixed;
      left: 50%;
      background: rgba(30,41,59,0.95);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(99,102,241,0.7);
      z-index: 3000;
      display: none;
      opacity: 0;
      transform: translateX(-50%);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .popup-info.show,
    .hidden-popup.show,
    .omikuji-popup.show {
      display: block;
      opacity: 1;
      transform: translateX(-50%);
      animation: fadeInUp 0.3s ease;
    }
    .popup-info button {
      position: absolute;
      top: 0.5rem;
      right: 0.75rem;
      background: transparent;
      border: none;
      color: #f87171;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .omikuji-popup {
      top: 20%;
      max-width: 80%;
      width: 90%;
    }
    .show-btn {
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      padding: 0.75rem 1.6rem;
      font-size: 1rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 0.8rem;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    }
    .show-btn:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(37,99,235,0.4);
    }
    footer {
      margin-top: 2rem;
      color: #a0aec0;
      font-size: 0.85rem;
      text-align: center;
      transition: opacity 0.3s ease;
    }
    @media (max-width: 480px) {
      .profile-icon {
        width: 8rem;
        height: 8rem;
      }
      .profile-box h2 { font-size: 1.3rem; }
      .profile-box p { font-size: 0.95rem; }
      .link-section a {
        font-size: 0.95rem;
        padding: 0.6rem 1rem;
      }
      footer { font-size: 0.75rem; }
    }
    table.reversi-board {
      margin: 10px auto;
      border-collapse: collapse;
      position: relative;
    }
    .reversi-board td {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      position: relative;
    }

    .reversi-board td.hint::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: rgba(0, 0, 0, 0.2); /* è–„ãé»’ã„ */
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    table.reversi-board td.black { background: radial-gradient(circle, #000 60%, transparent 60%); }
    table.reversi-board td.white { background: radial-gradient(circle, #fff 60%, transparent 60%); }

    .ai-viz-overlay {
      pointer-events: none;
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8em;
      color: white;
      background-color: rgba(0,0,0,0.5);
      border-radius: 4px;
    }
    .toggle-container {
      margin: 8px;
    }

    /* Flip animation */
    @keyframes flip {
      0% {
        transform: rotateY(0deg);
      }
      50% {
        transform: rotateY(90deg);
        background: transparent;
      }
      100% {
        transform: rotateY(0deg);
      }
    }
    .flip {
      animation: flip 0.6s ease forwards;
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    #runnerCanvas {
      background-color: #87ceeb;
      border: 2px solid #000;
      display: block;
      margin: 0 auto;
    }
  </style>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-72E0Z6REMG"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-72E0Z6REMG');
  </script>
  </head>
  <script>
    const getCookie = (key) => {
      return document.cookie.split('; ').find(c => c.startsWith(key + '='))?.split('=')[1] || null;
    };

    const setCookie = (key, val, days) => {
      const d = new Date();
      d.setTime(d.getTime() + days * 864e5);
      document.cookie = `${key}=${val}; expires=${d.toUTCString()}; path=/`;
    };

    function showWarningA() {
      document.body.innerHTML = `
        <div style="padding:50px;font-family:'Courier New',monospace;color:#ff4d4d;background:#000;height:100vh;">
          <h1 style="font-size:3em;">âš ï¸ã€è­¦å‘Š - ä¸å¯©ãªæŒ™å‹•ã‚’æ¤œå‡ºã€‘âš ï¸</h1>
          <p style="font-size:1.4em;line-height:2;">
            ç¾åœ¨ã€ã“ã®ãƒšãƒ¼ã‚¸ã«ãŠã„ã¦<strong>é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®èµ·å‹•ã¾ãŸã¯ã‚³ãƒ¼ãƒ‰è§£æã®è©¦ã¿</strong>ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚<br><br>
            ã“ã®è¡Œç‚ºã¯ã€Webãƒšãƒ¼ã‚¸ã®ä¿è­·ã•ã‚ŒãŸæ§‹é€ ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç›®çš„ã¨ã—ãŸã‚‚ã®ã§ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€<br>
            <strong>ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢æ³•ï¼ˆæ—¥æœ¬ï¼‰ç¬¬3æ¡</strong>ç­‰ã®æ³•ä»¤ã«æŠµè§¦ã™ã‚‹æã‚ŒãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ãŠå®¢æ§˜ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ»ãƒ–ãƒ©ã‚¦ã‚¶æŒ‡ç´‹ãƒ»ã‚¢ã‚¯ã‚»ã‚¹çµŒè·¯ãƒ»æ“ä½œã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¯æ—¢ã«è¨˜éŒ²ã•ã‚Œã€<br>
            ç¶™ç¶šçš„ãªç›£è¦–å¯¾è±¡ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¾ã—ãŸã€‚<br><br>
            æœ¬ãƒšãƒ¼ã‚¸ã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿è­·ã®ãŸã‚ç•°å¸¸ã‚¢ã‚¯ã‚»ã‚¹ã«å¯¾ã—ã¦è‡ªå‹•å¿œç­”ã‚·ã‚¹ãƒ†ãƒ ã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚<br>
            ä¸æ­£ãªã‚¢ã‚¯ã‚»ã‚¹ãŒç¶™ç¶šã•ã‚Œã‚‹å ´åˆã€<strong>é€šä¿¡ã®é®æ–­ãƒ»åˆ¶é™ã€ã¾ãŸã¯æ³•çš„é€šçŸ¥</strong>ãŒè¡Œã‚ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ğŸ”’ã€è¨˜éŒ²æ¸ˆã¿æƒ…å ±ã€‘<br>
            â–¸ IPã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆåŒ¿ååŒ–ã•ã‚Œã¾ã›ã‚“ï¼‰<br>
            â–¸ User-Agent<br>
            â–¸ æ“ä½œå±¥æ­´ï¼ˆé–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®é–‹é–‰ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å«ã‚€ï¼‰<br><br>
            æœ¬ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚µãƒ¼ãƒãƒ¼ã¸é€ä¿¡ã•ã‚Œã€æ”¹ã–ã‚“ãƒ»å›é¿ã¯ã§ãã¾ã›ã‚“ã€‚<br><br>
            ğŸš«<strong>ã“ã‚Œä»¥ä¸Šã®è§£æè¡Œç‚ºã¯ç›´ã¡ã«ä¸­æ­¢ã—ã¦ãã ã•ã„ã€‚</strong>
          </p>
        </div>
      `;
    }


    function showWarningB() {
      document.body.innerHTML = `
        <div style="padding:50px;font-family:'Courier New',monospace;color:#ff0000;background:#000;height:100vh;">
          <h1 style="font-size:3em;">ğŸš¨ã€é‡å¤§è­¦å‘Šã€‘å†çŠ¯è¡Œç‚ºãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ ğŸš¨</h1>
          <p style="font-size:1.4em;line-height:2;">
            å†åº¦ã€é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ãƒ»ãƒšãƒ¼ã‚¸å†…éƒ¨æ§‹é€ ã®æ¤œæŸ»ã‚’è©¦ã¿ãŸç—•è·¡ãŒç¢ºèªã•ã‚Œã¾ã—ãŸã€‚<br><br>
            ã“ã‚Œã¯å˜ãªã‚‹é–²è¦§ã‚’è¶…ãˆãŸã€<strong>æ„å›³çš„ãªãƒªãƒãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒ»æ”¹ã–ã‚“è¡Œç‚º</strong>ã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚<br><br>
            ğŸ“¡ ã™ã§ã«ä»¥ä¸‹ã®æƒ…å ±ãŒè¤‡æ•°å›è¨˜éŒ²ã•ã‚Œã€<strong>é«˜åº¦ãªç›£è¦–çŠ¶æ…‹</strong>ã«ç§»è¡Œã—ã¾ã—ãŸï¼š<br>
            â–¸ IPã‚¢ãƒ‰ãƒ¬ã‚¹<br>
            â–¸ ãƒ–ãƒ©ã‚¦ã‚¶è­˜åˆ¥æƒ…å ±ï¼ˆCanvas Fingerprint ç­‰ã‚’å«ã‚€ï¼‰<br>
            â–¸ æ“ä½œãƒ­ã‚°ï¼ˆè§£ææ—¥æ™‚ãƒ»æ»åœ¨æ™‚é–“ãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é †åºï¼‰<br><br>
            ã“ã®æƒ…å ±ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç®¡ç†è€…ã«å³æ™‚é€ä¿¡ã•ã‚Œã€<strong>èª¿æŸ»å¯¾è±¡ç«¯æœ«ã¨ã—ã¦ãƒªã‚¹ãƒˆåŒ–</strong>ã•ã‚Œã¾ã—ãŸã€‚<br><br>
            âš–ï¸ æœ¬è¡Œç‚ºãŒç¶šãå ´åˆã€æŠ€è¡“çš„æªç½®ã«åŠ ãˆã¦ã€<strong>ãƒ—ãƒ­ãƒã‚¤ãƒ€ã¸ã®é€šå‘Šãƒ»æ³•çš„æ‰‹ç¶šã</strong>ã‚’å–ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚<br><br>
            ğŸ” æœ¬ãƒšãƒ¼ã‚¸ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šä¿è­·ã•ã‚Œã¦ãŠã‚Šã€å›é¿ãƒ»å½è£…ã¯ä¸å¯èƒ½ã§ã™ã€‚<br>
            ã“ã®ã¾ã¾ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç¶™ç¶šã—ãŸå ´åˆã€<strong>å¼·åˆ¶é®æ–­ãƒ»æ°¸ç¶šçš„ãªã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢æªç½®</strong>ãŒå³åº§ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚<br><br>
            ğŸš¨<strong>ä»Šã™ãã™ã¹ã¦ã®é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã‚’é–‰ã˜ã€ãƒšãƒ¼ã‚¸ã‹ã‚‰é›¢ã‚Œã¦ãã ã•ã„ã€‚</strong>
          </p>
        </div>
      `;
    }


    function detectDebugger() {
      let triggered = false;

      let count = parseInt(getCookie("warn_count") || "0", 10);

      if (count >= 2) {
        showWarningB();
        return;
      }

      const check = () => {
        const before = new Date();
        debugger;
        const after = new Date();

        if (after - before > 10 && !triggered) {
          triggered = true;
          count++;
          setCookie("warn_count", count);
          if (count >= 2) {
            showWarningB();
          } else {
            setTimeout(showWarningA, 3000);
          }
        }
      };

      setInterval(check, 1000);
    }

    window.addEventListener("DOMContentLoaded", detectDebugger);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js"></script>
  <body>
    <header>
      <h1>Welcome to Astral Site</h1>
      <p>Astral Profile</p>
    </header>
    <main>
      <section class="profile-box">
        <img src="https://i.gyazo.com/25618f47093149f3faff9c96caad3bb3.png" alt="Avatar" class="profile-icon" />
        <h2>Rusk&Sapphyä½¿ã„ / Black-Astral</h2>
        <p>è‡ªç”±ãã¾ã¾ã«ç”Ÿãã¦ã‚‹ç”Ÿç‰©ã€é›»è»ŠãŒã™ãã ã£ãŸã‚Š</p>
      </section>
      <section class="link-section">
        <h3>ğŸ”— ãƒªãƒ³ã‚¯é›†</h3>
        <ul>
          <li>
            <a href="https://vrchat.com/home/launch?worldId=wrld_545838b6-644e-4f2e-adec-65646637b788" target="_blank">ğŸŒ ãƒ›ãƒ¼ãƒ ãƒ¯ãƒ¼ãƒ«ãƒ‰</a>
          </li>
          <li>
            <a href="https://vrchat.com/home/user/usr_5e075627-8b85-4bce-9242-7f3fd2ade453" target="_blank">ğŸ’¬ VRChat ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«</a>
          </li>
          <li>
            <a href="https://x.com/AstralStelldayo" target="_blank">ğŸ¦ Xï¼ˆæ—§Twitterï¼‰</a>
          </li>
          <li>
            <a href="https://astralshop.booth.pm/" target="_blank">ğŸ› Booth</a>
          </li>
        </ul>
      </section>
      <section id="noticeBox" class="popup-info">
        <button onclick="hideNotice()">Ã—</button>
        <h3>ğŸ“¢ ãŠçŸ¥ã‚‰ã›</h3>
        <p>ç¾åœ¨ç‰¹ã« ãŠçŸ¥ã‚‰ã›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
      </section>
      <button class="show-btn" onclick="showNotice()">ãŠçŸ¥ã‚‰ã›ã‚’è¡¨ç¤º</button>
      <!-- XREAç”¨åºƒå‘Š -->
      <div class="xrea-banner" id="xreaAd">
        <h3>XREAç”¨åºƒå‘Š</h3>
        <script src="https://cache1.value-domain.com/xa.j?site=astraldao.s323.xrea.com"></script>
      </div>
    </main>
    <footer>
      <p>&copy; 2025 AstralSHOP. All Rights Reserved.</p>
      <p>Site Version 2025.4.16.2105</p>
    </footer>
    <script>
    const showNotice = () => {
      const notice = document.getElementById('noticeBox');
      if (notice) {
        notice.style.top = '20%';
        notice.classList.add('show');
      }
    };
    const hideNotice = () => {
      const notice = document.getElementById('noticeBox');
      if (notice) {
        notice.classList.remove('show');
      }
    };
    
    
    // DOMContentLoadedæ™‚ã®å‡¦ç†ï¼šXREAåºƒå‘Šè¡¨ç¤º
    window.addEventListener('DOMContentLoaded', () => {
      const ad = document.getElementById('xreaAd');
      if (ad && getCookie('adHidden') !== 'true') {
        ad.style.display = 'block';
        setTimeout(() => {
          ad.style.display = 'none';
          setCookie('adHidden', 'true', 7);
        }, 5000);
      }
    });
    
    let tapCount = 0, tapLimit = 10;
    const icon = document.querySelector('.profile-icon');
    if (icon) {
      icon.addEventListener('click', () => {
        tapCount++;
        if (tapCount === tapLimit) {
          showHiddenFeature();
          tapCount = 0;
        }
      });
    }
    
    const showHiddenFeature = () => {
      const existingPopup = document.querySelector('.hidden-popup');
      if(existingPopup) { existingPopup.remove(); }
      const hiddenFeature = document.createElement('div');
      hiddenFeature.className = 'hidden-popup';
      hiddenFeature.style.top = '20%';
      hiddenFeature.innerHTML = `
        <button onclick="this.parentElement.remove()" style="position:absolute;top:0.5rem;right:0.75rem;background:transparent;border:none;color:#f87171;font-size:1.2rem;cursor:pointer;">Ã—</button>
        <h3>ğŸ”’ éš ã—æ©Ÿèƒ½ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
        <p>å¥½ããªéŠã³ã‚’é¸ã‚“ã§ã­ï¼š</p>
        <div style="height: 1rem;"></div>
        <button onclick="startBlockGame()" class="show-btn">ğŸ® ãƒ–ãƒ­ãƒƒã‚¯ããšã—</button>
        <button onclick="startOmikuji()" class="show-btn" style="margin-top:0.5rem;">ğŸ² ãŠã¿ãã˜</button>
        <button onclick="initReactionGame()" class="show-btn" style="margin-top:0.5rem;">â± åå°„ç¥çµŒã‚²ãƒ¼ãƒ </button>
        <button onclick="initSnakeGame()" class="show-btn" style="margin-top:0.5rem;">ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ </button>
        <button onclick="initReversiGame()" class="show-btn" style="margin-top:0.5rem;">âšªï¸ãƒªãƒãƒ¼ã‚·</button>
        <button onclick="openWebOsu()" class="show-btn" style="margin-top:0.5rem;">ğŸµ osu</button>
        <button onclick="openMinesweeper()" class="show-btn" style="margin-top:0.5rem;">ğŸ’£ ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</button>
        <div id="hidden-content" style="margin-top:1rem;"></div>
      `;
      document.body.appendChild(hiddenFeature);
      setTimeout(() => { 
        hiddenFeature.classList.add('show'); 
        hiddenFeature.style.display = 'block';
      }, 10);
    };
    
    let blockLevel = 1;
    let blockBricks = [];

    function loadLevel(level) {
      blockBricks = [];
      const maxPresetLevels = 15;
      let rowCount = 3 + Math.floor(level / 2);
      let colCount = 5 + Math.floor(level / 3);
      if (level <= maxPresetLevels) {
        loadPresetLevel(level, rowCount, colCount);
      } else {
        for (let row = 0; row < rowCount; row++) {
          for (let col = 0; col < colCount; col++) {
            if (Math.random() > 0.3) {
              blockBricks.push({
                x: col * (50 + 5) + 20,
                y: row * (20 + 5) + 20,
                width: 50,
                height: 20,
                destroyed: false
              });
            }
          }
        }
      }
    }

    function loadPresetLevel(level, rows, cols) {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          blockBricks.push({
            x: col * (50 + 5) + 20,
            y: row * (20 + 5) + 20,
            width: 50,
            height: 20,
            destroyed: false
          });
        }
      }
    }

    function resetBallAndPaddle(canvas, ctx) {
      ballX = canvas.width / 2;
      ballY = canvas.height - 30;
      dx = 2;
      dy = -2;
      paddleX = (canvas.width - paddleWidth) / 2;
    }

    function nextBlockLevel(canvas, ctx) {
      blockLevel++;
      loadLevel(blockLevel);
      resetBallAndPaddle(canvas, ctx);
    }

    let ballX, ballY, dx, dy;
    let paddleX;
    const paddleHeight = 10, paddleWidth = 60;

    function startBlockGame() {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `<canvas id="blockGame" width="300" height="200" style="background:#111; display:block; margin:1rem auto; border:2px solid #ccc;"></canvas>`;
  
      const canvas = document.getElementById("blockGame");
      const ctx = canvas.getContext("2d");

      let rightPressed = false, leftPressed = false, upPressed = false, downPressed = false;

      document.addEventListener("keydown", (e) => {
        if (e.key === "d" || e.key === "D") rightPressed = true;
        else if (e.key === "a" || e.key === "A") leftPressed = true;
        else if (e.key === "w" || e.key === "W") upPressed = true; 
        else if (e.key === "s" || e.key === "S") downPressed = true; 
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "d" || e.key === "D") rightPressed = false;
        else if (e.key === "a" || e.key === "A") leftPressed = false;
        else if (e.key === "w" || e.key === "W") upPressed = false;
        else if (e.key === "s" || e.key === "S") downPressed = false;
      });

      blockLevel = 1;
      loadLevel(blockLevel);
      resetBallAndPaddle(canvas, ctx);

      function collisionDetection() {
        blockBricks.forEach((brick) => {
          if (!brick.destroyed) {
            if (
              ballX > brick.x &&
              ballX < brick.x + brick.width &&
              ballY > brick.y &&
              ballY < brick.y + brick.height
            ) {
              dy = -dy;
              brick.destroyed = true;
            }
          }
        });
      }

      function drawBlockGame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
        blockBricks.forEach((brick) => {
          if (!brick.destroyed) {
            ctx.beginPath();
            ctx.rect(brick.x, brick.y, brick.width, brick.height);
            ctx.fillStyle = "#34d399";
            ctx.fill();
            ctx.closePath();
          }
        });

        ctx.beginPath();
        ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
        ctx.fillStyle = "#63b3ed";
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = "#facc15";
        ctx.fill();
        ctx.closePath();

        collisionDetection();

        if (ballX + dx > canvas.width - 5 || ballX + dx < 5) {
          dx = -dx;
        }
        if (ballY + dy < 5) {
          dy = -dy;
        } else if (ballY + dy > canvas.height - 5) {
          if (ballX > paddleX && ballX < paddleX + paddleWidth) {
            dy = -dy;
          } else {
            hiddenContent.innerHTML = "<p style='color:tomato;text-align:center;margin-top:1rem;'>ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ã‚‚ã†ä¸€åº¦ãƒ–ãƒ­ãƒƒã‚¯ããšã—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†é–‹</p>";
            return;
          }
        }

        ballX += dx;
        ballY += dy;
        if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
        else if (leftPressed && paddleX > 0) paddleX -= 5;

        if (blockBricks.every(brick => brick.destroyed)) {
          nextBlockLevel(canvas, ctx);
        }

        requestAnimationFrame(drawBlockGame);
      }

      drawBlockGame();
    }

    
    const startOmikuji = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div class="omikuji-loading" style="padding:1rem; text-align:center; border:2px solid #63b3ed; border-radius:0.8rem; background:#1e293b; margin-top:1rem;">
          <h3>ãŠã¿ãã˜ã‚’å¼•ã„ã¦ã„ã¾ã™â€¦</h3>
          <div class="spinner" style="margin:1rem auto; width:40px; height:40px; border:4px solid #63b3ed; border-top:4px solid #1e293b; border-radius:50%; animation: spin 1s linear infinite;"></div>
        </div>
      `;
      setTimeout(() => {
        const results = [ "å¤§å‰ ğŸ‰", "ä¸­å‰ ğŸ™‚", "å°å‰ ğŸ˜Š", "å‰ ğŸ‘", "æœ«å‰ ğŸ¤", "å‡¶ ğŸ˜", "å¤§å‡¶ ğŸ’¥" ];
        const randomResult = results[Math.floor(Math.random() * results.length)];
        hiddenContent.innerHTML = `
          <div style="padding:1rem; text-align:center; border:2px solid #63b3ed; border-radius:0.8rem; background:#1e293b; margin-top:1rem; transition: transform 0.3s ease;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
            <h3>ãŠã¿ãã˜ã®çµæœ</h3>
            <p style="font-size:1.5rem; font-weight:bold;">${randomResult}</p>
          </div>
        `;
      }, 2000);
    };
    
    let reactionStartTime, reactionTimeoutId;
    let reactionIsWaiting = false, reactionHasStarted = false;
    const initReactionGame = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div id="reactionGame" style="text-align:center; padding:20px;">
          <h2>ğŸ§  åå°„ç¥çµŒã‚²ãƒ¼ãƒ </h2>
          <div id="reactionBox" style="width:300px; height:200px; margin:20px auto; background-color:gray; line-height:200px; font-size:24px; color:white; cursor:pointer; border-radius:12px;">
            ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
          </div>
          <p id="reactionResult" style="font-size:1.5em; margin-top:20px; font-weight:bold;"></p>
          <button onclick="startReactionGame()" style="margin-top:20px; padding:10px 20px; font-size:1em; border:none; border-radius:8px; background-color:#2196f3; color:white; cursor:pointer;">
            ãƒªãƒˆãƒ©ã‚¤
          </button>
        </div>
      `;
      reactionStartTime = null;
      reactionTimeoutId = null;
      reactionIsWaiting = false;
      reactionHasStarted = false;
      setupReactionGame();
    };
    const setupReactionGame = () => {
      const reactionBox = document.getElementById("reactionBox");
      const reactionResult = document.getElementById("reactionResult");
      reactionBox.addEventListener("click", () => {
        if (!reactionHasStarted) {
          startReactionGame();
          return;
        }
        if (reactionIsWaiting) {
          clearTimeout(reactionTimeoutId);
          reactionResult.textContent = "âš ï¸ æ—©ã™ãï¼ã‚„ã‚Šç›´ã—ã¦ã­ã€‚";
          reactionBox.style.backgroundColor = "#f44336";
          reactionBox.textContent = "æ—©ã™ãï¼";
          reactionHasStarted = false;
        } else if (reactionStartTime) {
          const reactionTime = Date.now() - reactionStartTime;
          let comment = "";
          if (reactionTime < 200) comment = "ğŸ‘‘ ç¥åå¿œï¼";
          else if (reactionTime < 300) comment = "âš¡ é€Ÿã„ï¼";
          else if (reactionTime < 500) comment = "ğŸ‘ æ™®é€š";
          else comment = "ğŸ¢ é…ã‚...";
          reactionResult.textContent = `åå¿œé€Ÿåº¦: ${reactionTime} ms ${comment}`;
          reactionBox.textContent = "ã‚‚ã†ä¸€å›ï¼Ÿ";
          reactionBox.style.backgroundColor = "#2196f3";
          reactionHasStarted = false;
        }
      });
    };
    const startReactionGame = () => {
      const reactionBox = document.getElementById("reactionBox");
      const reactionResult = document.getElementById("reactionResult");
      reactionBox.style.backgroundColor = "gray";
      reactionBox.textContent = "å¾…ã£ã¦...";
      reactionResult.textContent = "";
      reactionIsWaiting = true;
      reactionHasStarted = true;
      reactionTimeoutId = setTimeout(() => {
        reactionBox.style.backgroundColor = "#4caf50";
        reactionBox.textContent = "ã‚¯ãƒªãƒƒã‚¯ï¼";
        reactionStartTime = Date.now();
        reactionIsWaiting = false;
      }, 2000 + Math.random() * 3000);
    };
    
    const initSnakeGame = () => {
      const hiddenContent = document.getElementById('hidden-content');
      hiddenContent.innerHTML = `
        <div id="snakeGameContainer" style="text-align:center;">
          <h2>ğŸ ã‚¹ãƒãƒ¼ã‚¯ã‚²ãƒ¼ãƒ </h2>
          <canvas id="snakeCanvas" width="400" height="400" style="background-color:#000; border:2px solid #0f0; margin:0 auto;"></canvas>
          <p>çŸ¢å°ã‚­ãƒ¼ã§æ“ä½œã—ã¦ã­ï¼</p>
        </div>
      `;
      const canvas = document.getElementById("snakeCanvas");
      const ctx = canvas.getContext("2d");
      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      let snake = [{ x: 10, y: 10 }];
      let apple = { x: 5, y: 5 };
      let dx = 1, dy = 0;
      let gameOver = false;
      function drawSnakeGame() {
        if (gameOver) return;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f00";
        ctx.fillRect(apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);
        ctx.fillStyle = "#0f0";
        snake.forEach(part => { ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize); });
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount ||
            snake.some(part => part.x === head.x && part.y === head.y)) {
          gameOver = true;
          alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼");
          location.reload();
          return;
        }
        snake.unshift(head);
        if (head.x === apple.x && head.y === apple.y) {
          apple = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
        } else {
          snake.pop();
        }
        setTimeout(drawSnakeGame, 100);
      }
      document.addEventListener("keydown", snakeKeyDown);
      function snakeKeyDown(e) {
        if (e.key === "ArrowUp" && dy === 0) { dx = 0; dy = -1; }
        else if (e.key === "ArrowDown" && dy === 0) { dx = 0; dy = 1; }
        else if (e.key === "ArrowLeft" && dx === 0) { dx = -1; dy = 0; }
        else if (e.key === "ArrowRight" && dx === 0) { dx = 1; dy = 0; }
      }
      drawSnakeGame();
    };
    
    const initReversiGame = () => {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div id="reversiGame" style="text-align:center;">
      <h2>ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰</h2>
      <table class="reversi-board" id="reversiBoard"></table>
      <p id="reversiStatus"></p>
      <label class="toggle-container" style="user-select: none; cursor: pointer;">
        <input type="checkbox" id="toggleAIMode" style="vertical-align: middle;">
        <span id="modeLabel" style="vertical-align: middle; margin-left: 8px;">AIãƒ¢ãƒ¼ãƒ‰: æœ¬æ°—</span>
      </label>
      <br>
      <label class="toggle-container" style="user-select: none; cursor: pointer;">
        <input type="checkbox" id="toggleAIViz" style="vertical-align: middle;">
        <span id="vizLabel" style="vertical-align: middle; margin-left: 8px;">AIæ€è€ƒå¯è¦–åŒ–ãƒ¢ãƒ¼ãƒ‰: OFF</span>
      </label>
      <br>
      <h3 style="margin-top:1em;">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å¯è¦–åŒ–ãƒ­ã‚°</h3>
      <div id="searchTreeVisualization" style="height:300px; overflow:auto; border:1px solid #ccc; text-align:left; font-size:12px; white-space: pre-wrap; background:#f9f9f9; padding:4px; font-weight: bold;"></div>
      <br>
      <canvas id="scoreChart" width="400" height="200"></canvas>  
      <p id="gameResult" style="font-size:20px; font-weight:bold; color:#333;"></p> 
    </div>
  `;

  let board = [], currentPlayer = 1, lastMove = null;
  const statusElem = document.getElementById("reversiStatus");
  const gameResultElem = document.getElementById("gameResult");
  let aiSeriousMode = true;  
  let aiVisualMode = false;

  let searchLog = [];

  const toggleAIModeEl = document.getElementById("toggleAIMode");
  const modeLabel = document.getElementById("modeLabel");
  toggleAIModeEl.checked = true;
  toggleAIModeEl.addEventListener("change", () => {
    aiSeriousMode = toggleAIModeEl.checked;
    modeLabel.textContent = aiSeriousMode ? "AIãƒ¢ãƒ¼ãƒ‰: æœ¬æ°—" : "AIãƒ¢ãƒ¼ãƒ‰: èˆã‚ãƒ—";
  });

  const toggleAIVizEl = document.getElementById("toggleAIViz");
  const vizLabel = document.getElementById("vizLabel");
  toggleAIVizEl.checked = false;
  toggleAIVizEl.addEventListener("change", () => {
    aiVisualMode = toggleAIVizEl.checked;
    vizLabel.textContent = aiVisualMode ? "AIæ€è€ƒå¯è¦–åŒ–ãƒ¢ãƒ¼ãƒ‰: ON" : "AIæ€è€ƒå¯è¦–åŒ–ãƒ¢ãƒ¼ãƒ‰: OFF";
    renderBoard();
  });

  const ctx = document.getElementById('scoreChart').getContext('2d');
  const scoreData = {
    labels: [],
    datasets: [{
      label: 'ã‚¹ã‚³ã‚¢',
      borderColor: 'rgba(75, 192, 192, 1)',
      data: [],
      fill: false,
      tension: 0.1
    },
    {
      label: 'äºˆæ¸¬ã‚¹ã‚³ã‚¢',
      borderColor: 'rgba(255, 99, 132, 1)',
      data: [],
      fill: false,
      tension: 0.1,
      borderDash: [5, 5] 
    }]
  };
  const scoreChart = new Chart(ctx, {
    type: 'line',
    data: scoreData,
    options: {
      scales: {
        x: { title: { display: true, text: 'ã‚¿ãƒ¼ãƒ³' } },
        y: { title: { display: true, text: 'è©•ä¾¡ã‚¹ã‚³ã‚¢' }, suggestedMin: -1000, suggestedMax: 1000 }
      }
    }
  });

  let bitHuman = (1n << BigInt(3 * 8 + 4)) | (1n << BigInt(4 * 8 + 3));
  let bitBot   = (1n << BigInt(3 * 8 + 3)) | (1n << BigInt(4 * 8 + 4));
  const MASK_LEFT  = 0x7f7f7f7f7f7f7f7fn;
  const MASK_RIGHT = 0xfefefefefefefefen;

  const shiftNorth = (x) => x >> 8n;
  const shiftSouth = (x) => x << 8n;
  const shiftEast  = (x) => (x << 1n) & MASK_RIGHT;
  const shiftWest  = (x) => (x >> 1n) & MASK_LEFT;
  const shiftNorthEast = (x) => (x >> 7n) & MASK_RIGHT;
  const shiftNorthWest = (x) => (x >> 9n) & MASK_LEFT;
  const shiftSouthEast = (x) => (x << 9n) & MASK_RIGHT;
  const shiftSouthWest = (x) => (x << 7n) & MASK_LEFT;

  function movesInDirection(bitPlayer, bitOpp, shiftFunc) {
    let mask = shiftFunc(bitPlayer) & bitOpp;
    for (let i = 0; i < 5; i++) {
      mask |= shiftFunc(mask) & bitOpp;
    }
    return shiftFunc(mask);
  }

  function getLegalMovesBit(bitPlayer, bitOpp) {
    const empty = ~(bitPlayer | bitOpp);
    let moves = 0n;
    moves |= movesInDirection(bitPlayer, bitOpp, shiftNorth);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftSouth);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftEast);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftWest);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftNorthEast);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftNorthWest);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftSouthEast);
    moves |= movesInDirection(bitPlayer, bitOpp, shiftSouthWest);
    return moves & empty;
  }

  function getMoveListFromBit(movesBit) {
    const moves = [];
    for (let pos = 0; pos < 64; pos++) {
      if (movesBit & (1n << BigInt(pos))) moves.push(pos);
    }
    return moves;
  }

  function makeMoveBit(bitPlayer, bitOpp, move) {
    const moveBit = 1n << BigInt(move);
    let flips = 0n;
    const directions = [shiftNorth, shiftSouth, shiftEast, shiftWest,
                        shiftNorthEast, shiftNorthWest, shiftSouthEast, shiftSouthWest];
    for (const shiftFunc of directions) {
      let flipped = 0n;
      let pos = shiftFunc(moveBit);
      while (pos && (pos & bitOpp)) {
        flipped |= pos;
        pos = shiftFunc(pos);
      }
      if (pos & bitPlayer) {
        flips |= flipped;
      }
    }
    bitPlayer |= moveBit | flips;
    bitOpp &= ~flips;
    return { bitPlayer, bitOpp };
  }

  function bitCount(n) {
    let count = 0;
    while (n) {
      count++;
      n &= n - 1n;
    }
    return count;
  }

  const weights = [
    [120, -20, 20, 5, 5, 20, -20, 120],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [5, -5, 3, 3, 3, 3, -5, 5],
    [20, -5, 15, 3, 3, 15, -5, 20],
    [-20, -40, -5, -5, -5, -5, -40, -20],
    [120, -20, 20, 5, 5, 20, -20, 120]
  ];
  const weightLinear = [];
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      weightLinear.push(weights[r][c]);
    }
  }

  const gpu = new GPU();
  const evalKernel = gpu.createKernel(function(boardArray, weights) {
    return boardArray[this.thread.x] * weights[this.thread.x];
  }).setOutput([64]);

  function evaluateBoardGPU(bitBot, bitHuman) {
    const boardArray = [];
    for (let pos = 0; pos < 64; pos++) {
      const mask = 1n << BigInt(pos);
      if (bitBot & mask) boardArray.push(1);
      else if (bitHuman & mask) boardArray.push(-1);
      else boardArray.push(0);
    }
    const staticScores = evalKernel(boardArray, weightLinear);
    let staticScore = 0;
    for (let i = 0; i < staticScores.length; i++) {
      staticScore += staticScores[i];
    }
    const totalPieces = bitCount(bitBot) + bitCount(bitHuman);
    const empty = 64 - totalPieces;
    if (empty < 12) return (bitCount(bitBot) - bitCount(bitHuman)) * 1000;
    return staticScore * 5 + 5000;
  }

  function evaluateBitEnhanced(bitBot, bitHuman) {
    let staticScore = 0;
    for (let pos = 0; pos < 64; pos++) {
      const mask = 1n << BigInt(pos);
      if (bitBot & mask) staticScore += weightLinear[pos];
      else if (bitHuman & mask) staticScore -= weightLinear[pos];
    }
    const totalPieces = bitCount(bitBot) + bitCount(bitHuman);
    const empty = 64 - totalPieces;
    if (empty < 12) return (bitCount(bitBot) - bitCount(bitHuman)) * 1000;
    const botLegal = bitCount(getLegalMovesBit(bitBot, bitHuman));
    const humanLegal = bitCount(getLegalMovesBit(bitHuman, bitBot));
    const mobilityScore = (botLegal - humanLegal) * 10;
    return staticScore + mobilityScore;
  }

  const transpositionTable = {};

  function hashBoard() {
    return bitBot.toString() + '-' + bitHuman.toString();
  }

  const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
  const isLegalForPlayer = (r, c, player) => {
    if (board[r][c] !== 0) return false;
    return directions.some(([dr, dc]) => checkDirectionForPlayer(r, c, dr, dc, player));
  };
  const checkDirectionForPlayer = (r, c, dr, dc, player) => {
    let i = r + dr, j = c + dc;
    let found = false;
    const opponent = player === 1 ? BOT : 1;
    while (i >= 0 && i < size && j >= 0 && j < size) {
      if (board[i][j] === 0) return false;
      if (board[i][j] === player) return found;
      if (board[i][j] !== opponent) return false;
      found = true;
      i += dr;
      j += dc;
    }
    return false;
  };
  const legalMovesForPlayer = (player) => {
    const moves = [];
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        if (isLegalForPlayer(r, c, player)) moves.push([r, c]);
      }
    }
    return moves;
  };
  function minimaxBit(bitBot, bitHuman, depth, alpha, beta, maximizingPlayer, currentDepth = 0) {
    const indent = "  ".repeat(currentDepth);
    searchLog.push(`${indent}â†’ æ·±ã• ${currentDepth} / æ®‹ã‚Š ${depth} / ${maximizingPlayer ? "Max" : "Min"} é–‹å§‹, Î±=${alpha}, Î²=${beta}`);
    const key = hashBoard() + '-' + depth + (maximizingPlayer ? 'max' : 'min');
    if (transpositionTable[key] !== undefined) {
      searchLog.push(`${indent}ã€€æ—¢ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: score=${transpositionTable[key].score}`);
      return transpositionTable[key];
    }
    let legal = maximizingPlayer 
      ? getLegalMovesBit(bitBot, bitHuman)
      : getLegalMovesBit(bitHuman, bitBot);
    if (depth === 0 || legal === 0n) {
      const score = aiSeriousMode ? evaluateBoardGPU(bitBot, bitHuman)
                                  : evaluateBitEnhanced(bitBot, bitHuman);
      searchLog.push(`${indent}â† è‘‰ãƒãƒ¼ãƒ‰: score=${score}`);
      return { score };
    }
    let bestMove = null;
    let moves = getMoveListFromBit(legal);
    if (aiSeriousMode) {
      if (maximizingPlayer) {
        moves.sort((m1, m2) => {
          let state1 = makeMoveBit(bitBot, bitHuman, m1);
          let state2 = makeMoveBit(bitBot, bitHuman, m2);
          let eval1 = evaluateBoardGPU(state1.bitPlayer, state1.bitOpp);
          let eval2 = evaluateBoardGPU(state2.bitPlayer, state2.bitOpp);
          return eval2 - eval1;
        });
      } else {
        moves.sort((m1, m2) => {
          let state1 = makeMoveBit(bitHuman, bitBot, m1);
          let state2 = makeMoveBit(bitHuman, bitBot, m2);
          let eval1 = evaluateBoardGPU(state1.bitOpp, state1.bitPlayer);
          let eval2 = evaluateBoardGPU(state2.bitOpp, state2.bitPlayer);
          return eval1 - eval2;
        });
      }
    }
    if (maximizingPlayer) {
      let maxScore = -Infinity;
      for (const move of moves) {
        const newState = makeMoveBit(bitBot, bitHuman, move);
        const res = minimaxBit(newState.bitPlayer, newState.bitOpp, depth - 1, alpha, beta, false, currentDepth + 1);
        if (res.score > maxScore) { 
          maxScore = res.score; 
          bestMove = move; 
        }
        alpha = Math.max(alpha, res.score);
        searchLog.push(`${indent}ã€€Maxãƒãƒ¼ãƒ‰: move ${move} å¾—ç‚¹=${res.score}, æ›´æ–°å¾ŒÎ±=${alpha}`);
        if (beta <= alpha) {
          searchLog.push(`${indent}ã€€Î²ã‚«ãƒƒãƒˆç™ºç”Ÿ: Î±=${alpha} Î²=${beta}`);
          break;
        }
      }
      const result = { score: maxScore, move: bestMove };
      transpositionTable[key] = result;
      searchLog.push(`${indent}â† Maxãƒãƒ¼ãƒ‰çµ‚äº†: score=${maxScore} æœ€è‰¯æ‰‹=${bestMove}`);
      return result;
    } else {
      let minScore = Infinity;
      for (const move of moves) {
        const newState = makeMoveBit(bitHuman, bitBot, move);
        const res = minimaxBit(newState.bitOpp, newState.bitPlayer, depth - 1, alpha, beta, true, currentDepth + 1);
        if (res.score < minScore) { 
          minScore = res.score; 
          bestMove = move; 
        }
        beta = Math.min(beta, res.score);
        searchLog.push(`${indent}ã€€Minãƒãƒ¼ãƒ‰: move ${move} å¾—ç‚¹=${res.score}, æ›´æ–°å¾ŒÎ²=${beta}`);
        if (beta <= alpha) {
          searchLog.push(`${indent}ã€€Î±ã‚«ãƒƒãƒˆç™ºç”Ÿ: Î±=${alpha} Î²=${beta}`);
          break;
        }
      }
      const result = { score: minScore, move: bestMove };
      transpositionTable[key] = result;
      searchLog.push(`${indent}â† Minãƒãƒ¼ãƒ‰çµ‚äº†: score=${minScore} æœ€è‰¯æ‰‹=${bestMove}`);
      return result;
    }
  }

  function iterativeDeepeningBit(maxDepth, timeLimit) {
    let best = null, start = Date.now();
    searchLog.push(`===== åå¾©æ·±åŒ–æ¢ç´¢é–‹å§‹: æœ€å¤§æ·±åº¦ ${maxDepth}, åˆ¶é™æ™‚é–“ ${timeLimit}ms =====`);
    for (let d = 1; d <= maxDepth; d++) {
      searchLog.push(`--- æ¢ç´¢æ·±åº¦ ${d} ã§æ¢ç´¢é–‹å§‹ ---`);
      const result = minimaxBit(bitBot, bitHuman, d, -Infinity, Infinity, true, 0);
      if (result.move !== undefined) best = result;
      searchLog.push(`--- æ¢ç´¢æ·±åº¦ ${d} çµ‚äº†, å¾—ç‚¹=${result.score} ---`);
      if (Date.now() - start > timeLimit) {
        searchLog.push(`*** æ™‚é–“åˆ¶é™åˆ°é”: ${Date.now()-start}ms ***`);
        break;
      }
    }
    searchLog.push(`===== åå¾©æ·±åŒ–æ¢ç´¢çµ‚äº†: æœ€çµ‚çµæœ: score=${best ? best.score : "undefined"}, move=${best ? best.move : "undefined"} =====`);
    updateSearchTreeVisualization();
    return best;
  }

  function updateSearchTreeVisualization() {
    const vizElem = document.getElementById("searchTreeVisualization");
    vizElem.textContent = searchLog.join("\n");
  }

  function updateBoardFromBit() {
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const pos = r * 8 + c;
        const mask = 1n << BigInt(pos);
        if (bitBot & mask) board[r][c] = BOT;
        else if (bitHuman & mask) board[r][c] = 1;
        else board[r][c] = 0;
      }
    }
  }

  const initBoard = () => {
    board = Array.from({ length: size }, () => Array(size).fill(0));
    board[3][3] = board[4][4] = BOT;
    board[3][4] = board[4][3] = 1;
  };

  const renderBoard = () => {
    const table = document.getElementById("reversiBoard");
    table.innerHTML = "";
    for (let r = 0; r < size; r++) {
      const tr = document.createElement("tr");
      for (let c = 0; c < size; c++) {
        const td = document.createElement("td");
        td.dataset.row = r;
        td.dataset.col = c;
        td.className = board[r][c] === 1 ? "black" : board[r][c] === BOT ? "white" : "";
        td.style.outline = lastMove && lastMove.row === r && lastMove.col === c ? "2px solid red" : "";
        if (currentPlayer === 1 && board[r][c] === 0 && isLegalForPlayer(r, c, 1))
          td.classList.add("hint");
        if (currentPlayer === 1)
          td.addEventListener("click", cellClick);
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    statusElem.textContent = currentPlayer === 1 ? "ã‚ãªãŸ(é»’)ã®ã‚¿ãƒ¼ãƒ³" : "BOT(ç™½)ã®ã‚¿ãƒ¼ãƒ³";

    if (aiVisualMode && currentPlayer !== 1) {
      renderAIVizOverlay();
    }
  };

  const renderAIVizOverlay = () => {
    const legal = getLegalMovesBit(bitBot, bitHuman);
    const moves = getMoveListFromBit(legal);
    moves.forEach(move => {
      const newState = makeMoveBit(bitBot, bitHuman, move);
      const evalScore = aiSeriousMode ? evaluateBoardGPU(newState.bitPlayer, newState.bitOpp)
                                      : evaluateBitEnhanced(newState.bitPlayer, newState.bitOpp);
      const r = Math.floor(move / size), c = move % size;
      const cell = document.querySelector(`#reversiBoard tr:nth-child(${r + 1}) td:nth-child(${c + 1})`);
      if (cell) {
        const overlay = document.createElement("div");
        overlay.className = "ai-viz-overlay";
        overlay.textContent = evalScore;
        cell.style.position = "relative";
        cell.appendChild(overlay);
      }
    });
  };

  const cellClick = (e) => {
    const r = parseInt(e.target.dataset.row), c = parseInt(e.target.dataset.col);
    if (!isLegalForPlayer(r, c, 1)) return;
    const pos = r * 8 + c;
    const result = makeMoveBit(bitHuman, bitBot, pos);
    bitHuman = result.bitPlayer;
    bitBot = result.bitOpp;
    currentPlayer = BOT;
    lastMove = { row: r, col: c };
    updateBoardFromBit();
    renderBoard();
    updateScoreChart();
    setTimeout(botTurn, 100);
  };

  const userCanMove = () => {
    return legalMovesForPlayer(1).length > 0;
  };

  const checkGameEnd = () => {
    const playerMoves = legalMovesForPlayer(1);
    const botMoves = legalMovesForPlayer(BOT);
    const empty = board.flat().filter(v => v === 0).length;
    if ((playerMoves.length === 0 && botMoves.length === 0) || empty === 0) {
      const botScore = board.flat().filter(v => v === BOT).length;
      const humanScore = board.flat().filter(v => v === 1).length;
      if (botScore > humanScore) {
        gameResultElem.textContent = `BOTã®å‹ã¡ï¼ (BOT: ${botScore} vs ã‚ãªãŸ: ${humanScore})`;
        gameResultElem.style.color = "red";
      } else if (botScore < humanScore) {
        gameResultElem.textContent = `ã‚ãªãŸã®å‹ã¡ï¼ (ã‚ãªãŸ: ${humanScore} vs BOT: ${botScore})`;
        gameResultElem.style.color = "blue";
      } else {
        gameResultElem.textContent = `å¼•ãåˆ†ã‘ï¼ (${humanScore} vs ${botScore})`;
        gameResultElem.style.color = "green";
      }
      return true;
    }
    return false;
  };

  const makeAIMove = () => {
    searchLog = [];
    if (aiSeriousMode) {
      return iterativeDeepeningBit(32, 10000);
    } else {
      return iterativeDeepeningBit(3, 1000);
    }
  };

  const makeMove = () => {
    const legal = getLegalMovesBit(bitBot, bitHuman);
    if (legal !== 0n) {
      const result = makeAIMove();
      if (result && result.move !== undefined) {
        const move = result.move;
        const r = Math.floor(move / size), c = move % size;
        const newState = makeMoveBit(bitBot, bitHuman, move);
        bitBot = newState.bitPlayer;
        bitHuman = newState.bitOpp;
        updateBoardFromBit();
        lastMove = { row: r, col: c };
        scoreData.labels.push(`ã‚¿ãƒ¼ãƒ³ ${scoreData.labels.length + 1}`);
        const evalScore = aiSeriousMode ? evaluateBoardGPU(bitBot, bitHuman)
                                        : evaluateBitEnhanced(bitBot, bitHuman);
        scoreData.datasets[0].data.push(evalScore);
        scoreData.datasets[1].data.push(evalScore);
        scoreChart.update();
      }
    }
    if (legalMovesForPlayer(1).length > 0 && !checkGameEnd()) {
      currentPlayer = 1;
      renderBoard();
    } else if (!checkGameEnd()) {
      statusElem.textContent = "ã‚ãªãŸã¯ç€æ‰‹ã§ãã¾ã›ã‚“ã€‚BOTãŒé€£ç¶šã§ç½®ãã¾ã™â€¦";
      setTimeout(botTurn, 1000);
      return;
    }
  };

  const botTurn = () => {
    const moves = getLegalMovesBit(bitBot, bitHuman);
    if (moves === 0n) {
      currentPlayer = 1;
      renderBoard();
      return;
    }
    const best = makeAIMove();
    if (best && best.move !== undefined) {
      const move = best.move;
      const result = makeMoveBit(bitBot, bitHuman, move);
      bitBot = result.bitPlayer;
      bitHuman = result.bitOpp;
      lastMove = { row: Math.floor(move / 8), col: move % 8 };
      updateBoardFromBit();
      renderBoard();
      updateScoreChart();
    }
    if (legalMovesForPlayer(1).length > 0 && !checkGameEnd()) {
      currentPlayer = 1;
      renderBoard();
    } else if (!checkGameEnd()) {
      setTimeout(botTurn, 1000);
    }
  };

  const updateScoreChart = () => {
    const turn = scoreData.labels.length + 1;
    const evalScore = aiSeriousMode ? evaluateBoardGPU(bitBot, bitHuman)
                                    : evaluateBitEnhanced(bitBot, bitHuman);
    const score = bitCount(bitBot) - bitCount(bitHuman);
    scoreData.labels.push(`ã‚¿ãƒ¼ãƒ³ ${turn}`);
    scoreData.datasets[0].data.push(score);
    scoreData.datasets[1].data.push(evalScore / 100);
    scoreChart.update();
  };

  initBoard();
  updateBoardFromBit();
  renderBoard();
};

initReversiGame();

















  const initRunnerGame = () => {
    const hiddenContent = document.getElementById('hidden-content');
    hiddenContent.innerHTML = `
      <div id="runnerGameContainer" style="text-align:center;">
        <h2>ğŸƒ ãƒ©ãƒ³ãƒŠãƒ¼ã‚²ãƒ¼ãƒ </h2>
        <canvas id="runnerCanvas" width="400" height="200" style="background-color:#87ceeb; border:2px solid #000; display:block; margin:0 auto;"></canvas>
        <p id="runnerScore">Score: 0</p>
        <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã‚’ã‚¿ãƒƒãƒ—ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼</p>
      </div>
    `;
    const canvas = document.getElementById("runnerCanvas");
    const ctx = canvas.getContext("2d");
    let runner = { x: 50, y: 150, width: 30, height: 30, vy: 0, jumping: false };
    const groundY = 150;
    const gravity = 0.6;
    let obstacles = [];
    let score = 0;
    let gameOver = false;
    let obstacleInterval = 1500; 
    let lastObstacleTime = Date.now();
    
    function drawRunnerGame() {
      if (gameOver) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#654321";
      ctx.fillRect(0, groundY + runner.height, canvas.width, canvas.height - groundY - runner.height);
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(runner.x, runner.y, runner.width, runner.height);
      runner.vy += gravity;
      runner.y += runner.vy;
      if (runner.y > groundY) {
        runner.y = groundY;
        runner.vy = 0;
        runner.jumping = false;
      }
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.x -= 5;
        ctx.fillStyle = "#000";
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        if (runner.x < obs.x + obs.width &&
            runner.x + runner.width > obs.x &&
            runner.y < obs.y + obs.height &&
            runner.y + runner.height > obs.y) {
          gameOver = true;
          alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ ã‚¹ã‚³ã‚¢: " + score);
          location.reload();
          return;
        }
        if (obs.x + obs.width < 0) {
          obstacles.splice(i, 1);
          score += 10;
          document.getElementById("runnerScore").textContent = "Score: " + score;
        }
      }
      if (Date.now() - lastObstacleTime > obstacleInterval) {
        const obsHeight = Math.random() * 20 + 20;
        obstacles.push({
          x: canvas.width,
          y: groundY + runner.height - obsHeight,
          width: 20,
          height: obsHeight
        });
        lastObstacleTime = Date.now();
      }
      requestAnimationFrame(drawRunnerGame);
    }
    drawRunnerGame();
    
    window.addEventListener("keydown", runnerKeyDown);
    function runnerKeyDown(e) {
      if (e.code === "Space" && !e.repeat) {  
        if (!runner.jumping) {
          runner.vy = -12;
          runner.jumping = true;
        }
      }
    }
  };
  function openWebOsu() {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div style="position: relative; width: 100%; height: 600px; border: 2px solid #ccc; border-radius: 0.8rem; overflow: auto;">
      <button onclick="closeWebOsu()" style="position: absolute; top: 0.5rem; right: 0.5rem; z-index:2; background:transparent;border:none;color:#f87171;font-size:1.2rem;cursor:pointer;">Ã—</button>
      <div style="width: 1280px; height: 800px; transform: scale(1); transform-origin: top left;">
        <iframe src="https://webosu.online/" style="width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
      </div>
      <div style="position: absolute; bottom: 0.3rem; right: 0.5rem; font-size: 0.75rem; color: #aaa; font-style: italic;">
        Powered by BlaNKtext
      </div>
    </div>
  `;
}


  function closeWebOsu() {
    const hiddenContent = document.getElementById('hidden-content');
    hiddenContent.innerHTML = "";
  }

function openMinesweeper() {
  const hiddenContent = document.getElementById('hidden-content');
  hiddenContent.innerHTML = `
    <div style="position: relative; width: 100%; max-height: 90vh; overflow-y: auto; border: 1px solid #ccc; border-radius: 0.75rem; padding: 1rem; background: #f9fafb; box-shadow: 0 0 10px rgba(0,0,0,0.05);">
      <button onclick="closeMinesweeper()" style="position: absolute; top: 0.5rem; right: 0.5rem; z-index: 2; background: transparent; border: none; color: #ef4444; font-size: 1.2rem; cursor: pointer;">Ã—</button>
      <h2 style="margin-top: 0; font-size: 1.25rem; color: #374151;">ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</h2>
      <div id="controls" style="margin-bottom: 10px; display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
        <button onclick="init(9, 9, 10)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">åˆç´š</button>
        <button onclick="init(16, 16, 40)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">ä¸­ç´š</button>
        <button onclick="init(30, 16, 99)" class="difficulty-btn" style="background-color: #f3f4f6; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">ä¸Šç´š</button>
      </div>
      <div id="status" style="font-weight: bold; margin: 0.5rem 0; color: #1f2937;">ğŸš© æ®‹ã‚Š: <span id="mine-count">0</span></div>
      <div id="game" style="display: grid; justify-content: center; gap: 2px;"></div>
    </div>
  `;

  const style = document.createElement('style');
  style.textContent = `
    .cell {
      width: 30px;
      height: 30px;
      background-color: #d1d5db;
      text-align: center;
      line-height: 30px;
      font-family: monospace;
      cursor: pointer;
      user-select: none;
      border-radius: 0.25rem;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    .cell:active {
      transform: scale(0.95);
    }
    .cell.opened {
      background-color: #f3f4f6 !important;
      cursor: default;
    }
    .cell.mine {
      background-color: #f87171 !important;
    }
    .cell.flagged {
      background-color: #c7d2fe !important;
    }
    .difficulty-btn.active {
      background-color: #3b82f6 !important;
      color: white;
    }
  `;
  document.head.appendChild(style);

  const script = document.createElement('script');
  script.type = 'text/javascript';
  script.text = `
    let board = [], width, height, mines, firstClick, openedCount, flaggedCount;

    function init(w, h, m) {
      width = w;
      height = h;
      mines = m;
      board = [];
      firstClick = true;
      openedCount = 0;
      flaggedCount = 0;
      const game = document.getElementById('game');
      game.innerHTML = '';
      game.style.gridTemplateColumns = \`repeat(\${width}, 30px)\`;
      game.style.gridTemplateRows = \`repeat(\${height}, 30px)\`;
      document.getElementById('status').style.color = '#1f2937';
      updateMineCount();

      document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
      const idx = [10, 40, 99].indexOf(m);
      if (idx !== -1) document.querySelectorAll('.difficulty-btn')[idx].classList.add('active');

      for (let y = 0; y < height; y++) {
        board[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.oncontextmenu = (e) => {
            e.preventDefault();
            toggleFlag(x, y);
          };
          cell.onclick = () => handleClick(x, y);
          game.appendChild(cell);

          board[y][x] = {
            el: cell,
            mine: false,
            opened: false,
            flagged: false,
            adjacent: 0
          };
        }
      }
    }

    function handleClick(x, y) {
      const cell = board[y][x];
      if (cell.opened || cell.flagged) return;

      if (firstClick) {
        placeMines(x, y);
        calcAdjacent();
        firstClick = false;
      }

      openCell(x, y);
      checkWin();
    }

    function toggleFlag(x, y) {
      const cell = board[y][x];
      if (cell.opened) return;
      cell.flagged = !cell.flagged;
      if (cell.flagged) {
        flaggedCount++;
        cell.el.textContent = 'ğŸš©';
        cell.el.classList.add('flagged');
      } else {
        flaggedCount--;
        cell.el.textContent = '';
        cell.el.classList.remove('flagged');
      }
      updateMineCount();
    }

    function updateMineCount() {
      const left = Math.max(mines - flaggedCount, 0);
      document.getElementById('mine-count').textContent = left;
    }

    function placeMines(safeX, safeY) {
      let placed = 0;
      while (placed < mines) {
        const x = Math.floor(Math.random() * width);
        const y = Math.floor(Math.random() * height);
        if (Math.abs(x - safeX) <= 1 && Math.abs(y - safeY) <= 1) continue;
        if (!board[y][x].mine) {
          board[y][x].mine = true;
          placed++;
        }
      }
    }

    function calcAdjacent() {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (board[y][x].mine) continue;
          let count = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                if (board[ny][nx].mine) count++;
              }
            }
          }
          board[y][x].adjacent = count;
        }
      }
    }

    function openCell(x, y) {
      const cell = board[y][x];
      if (cell.opened || cell.flagged) return;
      cell.opened = true;
      cell.el.classList.add('opened');
      openedCount++;

      if (cell.mine) {
        cell.el.textContent = 'ğŸ’£';
        cell.el.classList.add('mine');
        showStatus('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼', true);
        revealAll();
        return;
      }

      if (cell.adjacent > 0) {
        cell.el.textContent = cell.adjacent;
      } else {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
              openCell(nx, ny);
            }
          }
        }
      }
    }

    function revealAll() {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.opened) {
            cell.el.textContent = 'ğŸ’£';
            cell.el.classList.add('mine');
          }
          cell.el.onclick = null;
          cell.el.oncontextmenu = null;
        }
      }
    }

    function checkWin() {
      if (openedCount === width * height - mines) {
        showStatus('ğŸ‰ ã‚¯ãƒªã‚¢ï¼', false);
        revealAll();
      }
    }

    function showStatus(msg, isFail) {
      const status = document.getElementById('status');
      status.textContent = msg;
      status.style.color = isFail ? '#dc2626' : '#10b981';
    }

    init(9, 9, 10);
  `;
  document.body.appendChild(script);
}
function closeMinesweeper() {
  document.getElementById('hidden-content').innerHTML = '';
}
  </script>
  </body>
</html>
